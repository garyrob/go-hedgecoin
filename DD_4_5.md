# Weighted Committee Selection for go-algorand

## Design Document v4.5

**Target codebase:** go-algorand master branch (January 2026)

**Goal:** Modify Algorand's committee/proposer selection so that an external "weight" value **fully replaces** stake in all sortition inputs, with minimal code changes and no modifications to the external sortition package. Stake plays **no role**in either selection probability or eligibility. Eligibility is determined by the normal online/key-validity rules plus **non-zero external weight**. Selection probability, expected proposal intervals, and absenteeism thresholds are all determined exclusively by weight.

**Protocol requirement:** This is a weighted-selection network. All nodes must have a functioning weight daemon. Running without weights is not supported.

**Key difference from earlier designs:** There is no mixing of stake and weight. No `StakeFactor`, no `WeightFactor`, no `ComputeEffective` formula. Weight is passed directly to sortition as `money`, and total weight as `totalMoney`. Stake plays no role in selection probability or eligibility.

**Sortition approach:** This design uses the **same binomial sortition** mechanism as standard Algorand. The `sortition.Select(money, totalMoney, expectedSize, vrfOutput)` function is called with identical semantics — weight simply replaces stake as the `money` / `totalMoney` arguments. No changes to the external sortition package are required, and no code needs to be copied.

**Reward implication:** Block proposer payouts are a flat per-block amount (percentage of fees collected plus a protocol-defined bonus). The payout amount is independent of the proposer's stake or weight. Since proposer selection probability is now determined by weight, accounts with higher weight are selected more often and therefore earn more total rewards over time. No changes to the payout/reward machinery are required.

------

## 1. Weight Daemon Specification

This section defines the external weight daemon that algod relies upon. The daemon is **foundational** to this design; all later sections assume its properties.

### 1.1 Role and Authority

The **weight daemon is the authoritative source of truth** for external weights. It is a separate process from algod, maintaining its **own persistent database** independent of algod's state.

Algod **does not derive weights from on-chain events itself**; it always consults the daemon. Algod's local caching is strictly a performance optimization and may be incomplete or ephemeral without affecting correctness.

### 1.2 Timepoint Semantics

External weights are defined at discrete chain timepoints. Two round parameters are used in queries:

- **`balance_round`**: Identifies the balance snapshot round. This parameter applies to **both** query types. Per-account weights are defined as of this snapshot.
- **`vote_round`**: Identifies the round for which voting eligibility is being determined. This parameter applies **only to the total weight query** because the circulation population depends on both rounds (mirroring `Circulation(balanceRound, voteRound)`).

**Why two rounds for totals?** In Algorand, `Circulation(balanceRound, voteRound)` returns the total online stake at `balanceRound` for the **circulation population** at that round pair. This population can differ from a simple "eligible for voting at `voteRound`" definition depending on protocol flags and special cases (see "Circulation population semantics" below). The weight system must use the same two-round semantics for totals to maintain denominator alignment.

**Terminology note on Circulation:** Both the `agreement` and `ledger/eval` packages use two-round semantics for total online stake:

- The `agreement` package's `LedgerReader` interface: `Circulation(rnd basics.Round, voteRnd basics.Round) (basics.MicroAlgos, error)`
- The `ledger/eval` package's evaluator interfaces: `OnlineCirculation(rnd, voteRnd Round) (MicroAlgos, error)`

Both use the same two-round population semantics. The critical point is that **total weight must cover the same population as total stake**, even though total stake is no longer used in sortition.

**Circulation population semantics (CRITICAL):** The daemon's `total_weight(balanceRound, voteRound)`response must include exactly the same population that `OnlineCirculation(balanceRound, voteRound)` includes. In the current codebase, `OnlineCirculation`:

1. Gets total online stake at `balanceRound`, along with the **protocol version at `balanceRound`**.
2. If `ExcludeExpiredCirculation` is enabled **for the protocol at `balanceRound`** (NOT at `ParamsRound(voteRound)`) **and `balanceRound != 0`**, subtracts online stake for accounts with `VoteLastValid != 0 && VoteLastValid < voteRound`.
3. If `balanceRound == 0`, expired stake is **not** subtracted even if `ExcludeExpiredCirculation` is enabled. This is a special case: during the first `BalanceLookback` rounds (~320), agreement queries `OnlineCirculation(0, voteRound)` because `BalanceRound(voteRound, cparams)` saturates to 0. Genesis balances are used as-is.

The daemon MUST mirror this exactly. In particular:

- **Protocol version source:** Use the protocol version at `balance_round` to determine whether `ExcludeExpiredCirculation` is enabled — not the protocol at `vote_round` or `ParamsRound(vote_round)`.
- **Round-0 special case:** When `balance_round == 0`, do NOT subtract expired stake regardless of `ExcludeExpiredCirculation`. Return the total online supply from genesis.
- **Expired condition:** When subtraction applies, exclude accounts where `VoteLastValid != 0 AND VoteLastValid < vote_round`. Accounts with `VoteLastValid == 0` have perpetual key validity and are NEVER subtracted.
- **Include**: Online accounts at `balanceRound` whose keys are not expired per the above rule (even if suspended/knocked-off between rounds)
- **Do NOT exclude**: Suspended accounts, challenged accounts, or any status changes that occur between `balanceRound` and `voteRound` that `OnlineCirculation` does not exclude

**Early-round queries:** The daemon must support queries with `balance_round == 0` for any `vote_round` up to `BalanceLookback` (currently 320). These will occur during the first ~320 rounds of chain operation and also during catchpoint catchup that replays from genesis.

Failure to match this exactly will cause `TotalExternalWeight < ExternalWeight` panics when individual weights sum to more than the claimed total.

The daemon MUST answer queries for **any historical round or round combination** needed by algod's consensus verification, restart recovery, and catchpoint catchup.

### 1.3 Query Interface

The daemon exposes a TCP endpoint on `127.0.0.1:<port>` and supports the following request types:

**Connection semantics:** Each request is a single JSON object sent over a new TCP connection; the daemon replies with a single JSON object and the connection is then closed by the client. The daemon MUST support concurrent connections; algod may issue parallel lookups during validation, replay, and evaluation.

**Weight query:**

```
Request:  { "type": "weight", "address": "<addr>", "selection_id": "<selID>", "balance_round": "<round>" }
Response: { "weight": "<uint64>" }
```

**Total weight query:**

```
Request:  { "type": "total_weight", "balance_round": "<round>", "vote_round": "<round>" }
Response: { "total_weight": "<uint64>" }
```

**Identity query:** (see §1.7 for details)

```
Request:  { "type": "identity" }
Response: { "genesis_hash": "<base64>", "protocol_version": "<string>", "algorithm_version": "<string>" }
```

**Ping query:** (connectivity check)

```
Request:  { "type": "ping" }
Response: { "pong": true }
```

The ping query provides a lightweight health check. The daemon MUST respond with `{ "pong": true }` (success) or an error response. Alternatively, implementations MAY treat a successful TCP connect+close as a ping, but supporting the explicit ping request type is RECOMMENDED for consistency.

**Wire format specification:**

- `address`: Base32 Algorand address string (standard encoding with checksum)
- `selection_id`: Hex-encoded 32-byte VRF public key (`crypto.VRFVerifier` is a 32-byte type)
- `balance_round`, `vote_round`: Decimal string representation of uint64
- `weight`, `total_weight`: Decimal string representation of uint64

**Note on numeric encoding:** All uint64 values are encoded as decimal strings to ensure portability across implementations. JSON number types cannot represent all uint64 values exactly in many runtimes (notably JavaScript).

**Error response format:** For all request types, the daemon may return an error response instead of a success response:

```
Response: { "error": "<string>", "code": "<string>" }
```

- `error`: Human-readable error message
- `code`: Machine-readable error code. Standard codes include:
  - `"not_found"`: Requested account/round not found
  - `"bad_request"`: Malformed request
  - `"internal"`: Internal daemon error
  - `"unsupported"`: Unsupported request type or parameter

**Response mutual exclusivity:** Success responses and error responses are mutually exclusive:

- On **error responses**, the success fields (`weight`, `total_weight`, `genesis_hash`, etc.) **MUST be omitted**.
- On **success responses**, the error fields (`error`, `code`) **MUST be omitted**.

This simplifies client parsing and avoids ambiguous states.

**Deterministic error expectations:**

For any **valid** query parameters required by consensus (i.e., parameters that consensus code paths will actually use), the daemon **must not** return `"bad_request"` or `"unsupported"`. If it does, this indicates a software incompatibility or bug between algod and the daemon—not a transient condition.

The `"internal"` error code represents an **operational failure mode** (daemon unhealthy, resource exhaustion, transient DB failure). This is nondeterministic by nature. A node whose daemon returns `"internal"` will fail to proceed with consensus operations. This is acceptable as "node is down" behavior—consistent with the "oracle required" stance—but operators should understand that `"internal"` errors indicate daemon health issues requiring investigation.

The `"not_found"` error code for per-account weight queries should not occur in correctly functioning systems because algod only queries weights for accounts it has determined are in the circulation population (see §3.2). If `"not_found"` is returned for a query algod believes is for a circulation population participant, it indicates a daemon bug or population desync. For `total_weight(balanceRound, voteRound)` queries, `"not_found"` must not occur for any round pairs that consensus code will query; if it does, it indicates daemon incompleteness (persistence/history bug) and is treated as an invariant violation.

**Client behavior for error responses:**

- If `error` is present in the response, the client returns a typed `DaemonError` (see §4.2) preserving the `code`
- Callers use the error code to determine handling: `internal` → return error (operational); `not_found`/`bad_request`/`unsupported` → panic in eligibility-asserting paths (invariant violation)
- This distinguishes "daemon explicitly reports an error" from "TCP/JSON communication failure"
- The "zero is invalid for circulation population participants" rule is unaffected: zero weight in a success response for a circulation population participant still indicates a daemon bug

**Query semantics:**

- `weight(addr, selectionID, balanceRound)` → Returns the external weight for the specified account/key **at the balance snapshot** (independent of vote round). This represents the account's earned weight at that snapshot; the decision of whether to include this account in selection is made by algod's agreement logic based on eligibility at `voteRound`.
- `totalWeight(balanceRound, voteRound)` → Returns the deterministic sum of external weights over the **circulation population**—specifically, accounts counted by `OnlineCirculation(balanceRound, voteRound)` in algod. This includes online accounts at `balanceRound`, minus those with expired keys when the protocol requires it (see §1.2 for exact rules). The daemon MUST support this query for **any historical round combination** (not only the latest).

**Population definition:** The population summed by `totalWeight(balanceRound, voteRound)` MUST be exactly the same population counted by `OnlineCirculation(balanceRound, voteRound)` in algod — the "circulation population". Note that when `ExcludeExpiredCirculation` is disabled, this population may include accounts whose keys are not valid for `voteRound`. The daemon must match algod's denominator even when it seems counterintuitive. This ensures the weight denominator covers the same population used by algod for committee sizing.

**Consistency invariant:** For any `(balanceRound, voteRound)`, `totalWeight(balanceRound, voteRound)` must equal the sum of `weight(addr, selectionID, balanceRound)` over all `(addr, selectionID)` pairs in the circulation population at those rounds, where `(addr, selectionID)` are taken from the **balance snapshot state** at `balanceRound`.

**Non-zero weight requirement:** For any `(addr, selectionID)` that is in the **circulation population** for `(balanceRound, voteRound)`, the daemon MUST return `weight(addr, selectionID, balanceRound) > 0`. Returning zero for a participant in the circulation population is invalid and indicates a daemon or configuration error.

**Non-zero total requirement:** For any valid `(balanceRound, voteRound)` where the circulation population is non-empty, `totalWeight(balanceRound, voteRound) > 0`. If the circulation population is empty, `totalWeight` returning 0 is valid.

**Baseline weight implication:** The non-zero requirements above imply that the weight scheme must define a **strictly-positive baseline** (e.g., `>= 1`) for all participants in the circulation population, even brand-new ones. "Earned weight" or "reputation weight" is applied on top of this baseline. A participant cannot have zero external weight while remaining in the circulation population.

**Protocol choice — weight=0 is not a supported eligibility state:** This non-zero invariant is a deliberate protocol choice that simplifies denominator alignment and panic/error semantics throughout the codebase. Weight=0 is not a supported eligibility state for online circulation participants. If a future weight scheme needs to support "zero-weight but online" accounts (effectively excluded from selection while remaining in the circulation population), the panic checks in `membership()`, `Verify()`, and the absenteeism paths would need to be relaxed, the denominator alignment logic carefully re-verified, and weight=0 treated as "ineligible" rather than as an invariant violation. The current design does not support this.

### 1.4 Determinism Guarantees

The daemon computes weights as a **deterministic function of on-chain data**. For any valid query parameters:

> **All nodes querying any daemon instance must receive identical results.**

This is the fundamental consensus invariant. It holds because:

1. On-chain data is identical across all nodes
2. The weight derivation algorithm is deterministic
3. The daemon has access to complete blockchain history

### 1.5 Persistence and Historical Queries

The daemon maintains persistent storage sufficient to answer **both** query types for **any historical round or round combination**:

- `weight(addr, selectionID, balanceRound)`
- `totalWeight(balanceRound, voteRound)`

This is essential for:

- **Process restart safety:** If algod restarts and loses its local cache, it re-queries the daemon
- **Catchpoint/fast catchup safety:** Catchpoint catchup skips historical keyreg replay, but the daemon can still answer queries for any rounds needed during post-catchpoint verification
- **Consensus verification:** Historical queries during block validation and replay

The daemon does not rely on algod replay to know historical weights.

**Required property:** `totalWeight(balanceRound, voteRound)` must be computable and returnable even if the daemon has never received individual weight queries at those rounds. That is, total weight is computed independently by the daemon based on chain state, not "built up" by accumulating per-account queries from algod.

**Non-normative implementation note — Recommended storage model:** Weights typically change infrequently (e.g., when an account's reputation changes, not every round). The daemon should use **change-point / interval storage** rather than storing values for every round:

- For each `(addr, selectionID)`, maintain an ordered list of `(effective_from_round, weight)` change points
- Answer `weight(..., balanceRound)` by finding the last change point where `effective_from_round <= balanceRound`
- Storage grows with `O(#weight_changes)` rather than `O(#rounds)`

This model enables efficient historical queries without unbounded storage growth.

**Non-normative implementation note — Total weight storage:** Change-point storage guarantees `O(#weight_changes)` for per-account weights; however, `totalWeight(balanceRound, voteRound)` can change due to **eligibility transitions** between rounds (key validity windows, suspension status), even if individual weights change rarely. Total weight may require incremental maintenance or caching by the daemon to handle this efficiently.

### 1.6 Failure Mode

If the daemon is unavailable, algod cannot proceed with consensus operations that require weight lookups. Daemon availability is an operational requirement for all nodes in this network.

**Critical:** A cache miss in algod must **never** be interpreted as zero weight. A cache miss must trigger a daemon query. Zero is only correct if the daemon itself deterministically reports zero—and per the non-zero requirements above, zero is invalid for eligible participants.

### 1.7 Identity Handshake

To prevent "connected but wrong daemon" failures, the daemon supports an identity query that returns configuration metadata. This prevents scenarios where algod connects successfully but the daemon is serving data for a different chain, algorithm version, or network.

```
Request:  { "type": "identity" }
Response: { "genesis_hash": "<base64>", "protocol_version": "<string>", "algorithm_version": "<string>" }
```

**Fields:**

- `genesis_hash`: Base64-encoded genesis block hash (identifies the chain)
- `protocol_version`: Daemon protocol version string (for wire format compatibility)
- `algorithm_version`: Weight algorithm version identifier (ensures all nodes use the same weight derivation)

**Startup validation requirements:**

- `genesis_hash` **must match** the node's configured genesis hash. Mismatch is a fatal startup error.
- `algorithm_version` **must match** the expected value (compiled into the node as `ExpectedWeightAlgorithmVersion`). Mismatch is a fatal startup error because two nodes using different weight algorithms could derive different weights from the same chain state, breaking consensus.
- `protocol_version` **must match** the expected value (compiled into the node as `ExpectedWeightProtocolVersion`). Mismatch is a fatal startup error because different protocol versions may have incompatible wire formats.

------

## 2. Background: Current Selection Mechanism

### 2.1 Sortition Package (External)

The sortition implementation lives in `github.com/algorand/sortition`. The core function:

```go
// sortition/sortition.go
func Select(money uint64, totalMoney uint64, expectedSize float64, vrfOutput Digest) uint64
```

Internally, it computes:

```go
binomialN := float64(money)
binomialP := expectedSize / float64(totalMoney)
```

Then performs a binomial CDF walk using a ratio derived from `vrfOutput` normalized to [0,1).

**Key types:**

- `sortition.Digest` — a 32-byte array (`[sha512.Size256]byte`)
- `expectedSize` — `float64`, not `uint64`

**This package remains unchanged in our design.** Weight values are passed directly to `Select()` as `money` and `totalMoney`, using the exact same binomial mechanism that Algorand uses for stake-based selection.

### 2.2 Credential Verification

**File:** `data/committee/credential.go`

```go
func (cred UnauthenticatedCredential) Verify(
    proto config.ConsensusParams, 
    m Membership,
) (res Credential, err error)
```

This method:

1. Verifies the VRF proof against `m.Record.SelectionID` and `m.Selector`
2. Derives a credential digest `h` by hashing `(vrfOut || address)` or `hashableCredential` (domain-separated)
3. Retrieves stake: `userMoney := m.Record.VotingStake()`
4. Retrieves expected committee size: `expectedSelection := float64(m.Selector.CommitteeSize(proto))`
5. Calls sortition: `weight = sortition.Select(userMoney.Raw, m.TotalMoney.Raw, expectedSelection, sortition.Digest(h))`
6. Returns a `Credential` with the computed `Weight` field

**Invariant checks use `Panicf`, not error returns:**

```go
if m.TotalMoney.Raw < userMoney.Raw {
    logging.Base().Panicf("UnauthenticatedCredential.Verify: total money = %v, but user money = %v", m.TotalMoney, userMoney)
} else if m.TotalMoney.IsZero() || expectedSelection == 0 || expectedSelection > float64(m.TotalMoney.Raw) {
    logging.Base().Panicf("UnauthenticatedCredential.Verify: m.TotalMoney %v, expectedSelection %v", m.TotalMoney.Raw, expectedSelection)
}
```

### 2.3 Membership Struct

**File:** `data/committee/committee.go`

```go
// BalanceRecord pairs an account's address with its associated data.
// This struct is used to decouple LedgerReader.AccountData from basics.BalanceRecord.
//msgp:ignore BalanceRecord
type BalanceRecord struct {
    basics.OnlineAccountData
    Addr basics.Address
}

// Membership encodes the parameters used to verify membership in a committee.
type Membership struct {
    Record     BalanceRecord
    Selector   Selector
    TotalMoney basics.MicroAlgos
}
```

Note: `BalanceRecord` embeds `basics.OnlineAccountData`, NOT `basics.AccountData`.

**File:** `data/basics/userBalance.go`

```go
type OnlineAccountData struct {
    MicroAlgosWithRewards MicroAlgos
    VotingData                      // embedded: contains SelectionID, VoteID, etc.
    IncentiveEligible     bool
    LastProposed          Round
    LastHeartbeat         Round
}

// VotingStake returns the amount of MicroAlgos for participation.
// It assumes the caller has already updated rewards appropriately.
func (u OnlineAccountData) VotingStake() MicroAlgos {
    return u.MicroAlgosWithRewards
}
```

Note: `VotingStake()` is a **method**, not a field.

### 2.4 Membership Construction

**File:** `agreement/selector.go`

```go
func membership(l LedgerReader, addr basics.Address, r basics.Round, p period, s step) (m committee.Membership, err error) {
    cparams, err := l.ConsensusParams(ParamsRound(r))
    if err != nil {
        return
    }
    balanceRound := BalanceRound(r, cparams)
    seedRound := seedRound(r, cparams)

    record, err := l.LookupAgreement(balanceRound, addr)
    if err != nil {
        err = fmt.Errorf("Service.initializeVote (r=%d): Failed to obtain balance record for address %v in round %d: %w", r, addr, balanceRound, err)
        return
    }

    total, err := l.Circulation(balanceRound, r)
    if err != nil {
        err = fmt.Errorf("Service.initializeVote (r=%d): Failed to obtain total circulation in round %d: %v", r, balanceRound, err)
        return
    }

    seed, err := l.Seed(seedRound)
    if err != nil {
        err = fmt.Errorf("Service.initializeVote (r=%d): Failed to obtain seed in round %d: %v", r, seedRound, err)
        return
    }

    m.Record = committee.BalanceRecord{OnlineAccountData: record, Addr: addr}
    m.Selector = selector{Seed: seed, Round: r, Period: p, Step: s}
    m.TotalMoney = total
    return m, nil
}
```

**Note:** `Circulation(balanceRound, r)` takes two arguments: the balance snapshot round and the vote round `r`. This is critical for our design—see Section 1.2.

**Balance lookback is computed, not hardcoded:**

```go
func BalanceLookback(cparams config.ConsensusParams) basics.Round {
    return basics.Round(2 * cparams.SeedRefreshInterval * cparams.SeedLookback)
}

func BalanceRound(r basics.Round, cparams config.ConsensusParams) basics.Round {
    return r.SubSaturate(BalanceLookback(cparams))
}
```

Under current consensus parameters, `BalanceLookback` evaluates to 320 rounds.

### 2.5 Suspension/Absenteeism Mechanism

**File:** `ledger/eval/eval.go`

The `LedgerForCowBase` interface includes:

```go
GetKnockOfflineCandidates(basics.Round, config.ConsensusParams) (map[basics.Address]basics.OnlineAccountData, error)
```

The absenteeism detection logic computes expected proposal intervals based on stake ratios:

- Expected proposal interval: `n = TotalOnlineStake / AccountOnlineStake`
- Absent threshold: no proposal in `~20n` rounds

Absent accounts are added to `AbsentParticipationAccounts` in the block header. During block evaluation, these accounts have their `Status` set to `Offline` and `IncentiveEligible` set to `false`.

**File:** `ledger/apply/keyreg.go`

```go
func Keyreg(
    keyreg transactions.KeyregTxnFields,
    header transactions.Header,
    balances Balances,
    spec transactions.SpecialAddresses,
    ad *transactions.ApplyData,
    round basics.Round,
) error
```

When going online and `params.Payouts.Enabled` is true, sets `LastHeartbeat = round + BalanceLookback(cparams)` so the account isn't immediately flagged as absent. **Note:** This means `LastHeartbeat` can be in the future relative to the current round. (The "sufficient fee" check gates `IncentiveEligible`, not `LastHeartbeat`.)

### 2.6 Proposer Rewards (Payouts)

**File:** `ledger/eval/eval.go`

The proposer payout is a **flat per-block amount** calculated as:

```go
func (eval *BlockEvaluator) proposerPayout() (basics.MicroAlgos, error) {
    incentive, _ := basics.NewPercent(eval.proto.Payouts.Percent).DivvyAlgos(eval.block.FeesCollected)
    total, o := basics.OAddA(incentive, eval.block.Bonus)
    // ... overflow check, then cap at available balance in fee sink ...
    return basics.MinA(total, available), nil
}
```

The payout amount is **independent of the proposer's stake or weight**. It depends only on fees collected and a protocol-defined bonus. When `Payouts.Enabled` is true and the proposer is `IncentiveEligible`, the proposer receives this flat amount.

**Reward distribution follows selection probability:** Since proposer selection uses the same `sortition.Select`binomial mechanism, accounts selected more often earn more total rewards over time. In the original Algorand, this means rewards are proportional to stake (because selection probability ∝ stake). In our design, rewards become proportional to **weight** (because selection probability ∝ weight). No changes to the payout/reward code are required.

------

## 3. Design Approach

### 3.1 Core Principle: Replace Sortition Inputs with Weight

Instead of mixing stake and weight, we **replace** the sortition inputs entirely:

```
money      = accountWeight        (was: userStake)
totalMoney = totalWeight          (was: totalStake)
```

Then call the **same** `sortition.Select` function with the **same** binomial approach:

```go
sortition.Select(accountWeight, totalWeight, expectedSelection, sortition.Digest(h))
```

**Why this works:**

Sortition computes `binomialN = float64(money)` and `binomialP = expectedSize / float64(totalMoney)`. By substituting weight for stake in both numerator and denominator:

- The probability space remains correctly normalized: `sum(all account weights) / totalWeight = 1`
- Committee sizes remain correctly calibrated: `sum(all account probabilities) ≈ expectedSize`
- Relative selection probabilities between accounts are determined purely by their weight ratios
- The binomial CDF walk operates identically — it doesn't care whether the input represents stake or weight

**Stake plays no role in eligibility or selection:** The original code gates sortition on `!userMoney.IsZero()` (non-zero stake). This gate is removed. Eligibility for committee service and block proposal is determined by online status, key validity, and **non-zero external weight**. Weight then determines *how much* influence an eligible participant has. This matches the protocol requirement that no stake is required for eligibility.

### 3.2 Weight Sourcing

Weights are obtained from the daemon via two queries:

1. **Individual weight:** `daemon.Weight(addr, SelectionID, balanceRound)`
2. **Total weight:** `daemon.TotalWeight(balanceRound, voteRound)`

The total weight query uses **both `balanceRound` and `voteRound`** to match the semantics of `Circulation(balanceRound, voteRound)`. This ensures the weight denominator covers the same circulation population.

**Why per-account weight queries do not include `vote_round`:**

The per-account weight query is keyed only by `(addr, selectionID, balanceRound)`, while the total weight query includes `vote_round`. This asymmetry requires careful handling due to how vote verification operates.

**Critical: membership() runs BEFORE vote-key validity checks:**

In `agreement/vote.go`, the `membership()` function is called **before** the `VoteFirstValid`/`VoteLastValid` checks that determine whether a vote's participation key is valid for the current round. This means `membership()` will be called for **many ineligible/invalid messages** received from the network, as long as `LookupAgreement(balanceRound, addr)`succeeds.

This has critical implications for weight query error handling:

1. **For ineligible senders** (expired keys, keys not yet valid) **that are not in the circulation population**, the daemon may legitimately:

   - Not include them in `total_weight(balanceRound, voteRound)` (because `OnlineCirculation` itself may not include them, depending on the `ExcludeExpiredCirculation` protocol flag and the round-0 special case)
   - Return 0 or `not_found` for the per-account query (the non-zero weight requirement applies only to accounts **in** the circulation population; accounts excluded from it have no weight guarantee)

   **Conversely,** if an account with expired keys **is** still in the circulation population (e.g., because `ExcludeExpiredCirculation` is disabled), the daemon must still return `weight > 0` for that account. The population definition is determined solely by `OnlineCirculation`, not by algod-side key-validity gating.

   **Important:** `total_weight(balanceRound, voteRound)` must exactly mirror `OnlineCirculation(balanceRound, voteRound)`. The daemon must NOT independently decide to exclude additional accounts beyond what `OnlineCirculation` excludes. The key-validity gating described below is purely an algod-side optimization to prevent per-account queries (and panics) for messages that algod will reject anyway — it does not change the daemon's population definition.

2. **Naively panicking on zero weight or `not_found`** would create a **network-triggerable panic path**: an attacker could send votes from addresses with expired participation keys, causing algod to query the daemon and panic.

**Solution: Gate weight queries on vote-key validity:**

Inside `membership()`, after fetching `record` via `LookupAgreement()`, compute key eligibility:

```go
keyEligible := (r >= record.VoteFirstValid) && (record.VoteLastValid == 0 || r <= record.VoteLastValid)
```

Then:

- **Only perform** `ExternalWeight()`, `TotalExternalWeight()`, and all weight-related panic checks **if `keyEligible` is true**
- **If `keyEligible` is false**, leave the new `ExternalWeight` and `TotalExternalWeight` fields as zero and return `(m, nil)` as today; `vote.verify` will reject the message immediately afterward based on the same key validity check

This preserves current error semantics in `vote.verify` while preventing "invalid vote → daemon query → panic".

**Asymmetry rationale (after key-validity gating):**

- The **total weight query** includes `vote_round` because the daemon must independently compute the sum over the circulation population, which requires knowing both rounds (for vote-key expiry exclusion per §1.2)
- The **per-account query** is made only after algod has verified key eligibility (via the gating above), so algod knows the account is in the circulation population for that `voteRound`

**The total weight query is timepointed** and MUST be available for **any historical round combination** required by consensus verification paths (including replay verification and catchpoint verification). This is guaranteed by the daemon specification in Section 1.

**Operational invariant for per-account weight queries (after key-validity gating):** After verifying `keyEligible`, algod calls `ExternalWeight(balanceRound, addr, selectionID)` only for `(addr, selectionID)` pairs that are in the **circulation population** for `(balanceRound, voteRound)`. This invariant justifies the panic behavior when the daemon returns zero or `"not_found"` for such queries: if algod correctly identifies circulation population participants, the daemon must have their weights. A failure here indicates either a daemon bug or a population definition mismatch between algod and the daemon.

This invariant is enforced by:

- `membership()`: Key-validity gating ensures weight queries only occur for accounts with valid vote keys at the current round
- `generateKnockOfflineAccountsList()`: Iterates over `GetKnockOfflineCandidates()`, which returns only eligible online accounts
- `validateParticipationKeyWeights()`: Explicitly checks eligibility via `LookupAgreement()` before querying daemon (see §4.11)

### 3.3 No Stake/Weight Mixing

Earlier designs (DD 3.15) used a formula like `effective = (StakeFactor × stake) + (WeightFactor × weight)`. This design eliminates that entirely:

- **No `StakeFactor` or `WeightFactor` constants**
- **No `ComputeEffective` function**
- **No overflow risk from combining two large values**
- **Weight goes directly to sortition** as `money`/`totalMoney`
- **Stake is not checked** — eligibility is determined by online status, key validity, and non-zero weight

This is simpler, easier to reason about, and the only `uint64` overflow constraint is that weight values themselves fit in `uint64`, which is bounded by the daemon's weight scheme design.

### 3.4 Absenteeism Semantics

**Decision:** Absenteeism detection uses `(accountWeight, totalWeight)` for expected proposal intervals.

This ensures fairness: an account's expected proposal rate equals its selection probability (which is based on weight), so suspension thresholds are consistent with actual participation opportunities.

```
expectedInterval = totalWeight / accountWeight
absentThreshold  = 20 × expectedInterval
```

An account with higher weight is expected to propose more often and is therefore given a shorter absence threshold. This matches the actual selection probability.

### 3.5 Overflow and Failure Policy

**Policy:** All overflow conditions in consensus-critical code paths result in `Panicf`. This ensures identical failure behavior across all nodes, maintaining consensus even in failure cases.

This applies uniformly to:

- Credential verification (Section 4.6)
- Absenteeism detection (Section 4.9)—including the `20 × expectedInterval` threshold computation

Returning errors or using saturation arithmetic would risk divergent behavior across nodes or across future refactors.

------

## 4. Detailed Code Changes

### 4.1 Extend Membership Struct

**File:** `data/committee/committee.go`

```go
type Membership struct {
    Record       BalanceRecord
    Selector     Selector
    TotalMoney   basics.MicroAlgos
    
    // New fields for weight-based selection
    ExternalWeight      uint64            // This account's external weight
    TotalExternalWeight uint64            // Sum of all eligible online accounts' external weights
}
```

**Note:** `TotalMoney` is retained for minimal diff. It is still fetched via `Circulation()` in the `membership()` function, but it is **no longer referenced** in credential verification — the old `TotalMoney`-based invariant checks and stake gate are replaced by weight-based checks (§4.6). `VotingStake()` is still called but its value is not used for gating or selection. Removing `TotalMoney` entirely is a possible future cleanup.

**CRITICAL IMPLEMENTATION STEP — Membership construction audit:** The `committee.Membership` struct may be constructed in multiple locations throughout the codebase, not only in the `membership()` function. Before implementing, perform a codebase search for **both** `committee.Membership{...}` **and** `Membership{...}` literal constructions (the latter appears in test files within the same package) and update each one to include the new `ExternalWeight` and `TotalExternalWeight` fields. Failure to update all construction sites will result in zero values for the new fields, which will trigger the zero-weight panic in `Verify()`. This is consensus-critical: all nodes must construct identical `Membership` values.

### 4.2 Define Weight Oracle Interface and Error Types (Dependency Inversion)

To maintain correct dependency direction (`node/` → `ledger/`, not reverse), we define an interface and error types in a low-level package. This allows consensus-path packages (`agreement`, `ledger/eval`) to use the typed error without importing `node/`.

**File:** `ledger/ledgercore/weightoracle.go` (new file)

```go
package ledgercore

import (
    "errors"
    "fmt"
    
    "github.com/algorand/go-algorand/crypto"
    "github.com/algorand/go-algorand/data/basics"
)

// ExpectedWeightAlgorithmVersion is the weight algorithm version this node expects.
// Must match the daemon's algorithm_version for startup to succeed.
// This ensures all nodes use identical weight derivation logic.
const ExpectedWeightAlgorithmVersion = "1.0"

// ExpectedWeightProtocolVersion is the daemon protocol version this node expects.
// Must match the daemon's protocol_version for startup to succeed.
// This ensures wire format compatibility between algod and the daemon.
const ExpectedWeightProtocolVersion = "1.0"

// AbsenteeismMultiplier is the factor applied to expected proposal interval
// when computing the absenteeism threshold. This consolidates the existing
// absentFactor constant from ledger/eval/eval.go to ensure consistency
// across the weight-based absenteeism detection code.
const AbsenteeismMultiplier uint64 = 20

// DaemonError represents an error response from the weight daemon.
// This type is defined in ledgercore (not node/weightoracle) so that consensus-path
// packages (agreement, ledger/eval) can inspect error codes without importing node/.
// Callers can use errors.As to extract the Code for error-code-aware handling.
type DaemonError struct {
    Code string // Error code: "not_found", "bad_request", "internal", "unsupported"
    Msg  string // Human-readable error message
}

func (e *DaemonError) Error() string {
    return fmt.Sprintf("daemon error [%s]: %s", e.Code, e.Msg)
}

// IsDaemonError returns true if err is a DaemonError with the specified code.
func IsDaemonError(err error, code string) bool {
    var de *DaemonError
    if errors.As(err, &de) {
        return de.Code == code
    }
    return false
}

// WeightOracle provides external weight lookups for committee selection.
// The implementation is injected by the node layer.
//
// Method usage restrictions:
// - Weight() and TotalWeight() are used at runtime by agreement/eval/ledger code paths.
// - Ping() and Identity() are STARTUP-ONLY and must not be called from runtime code paths.
//   They exist on this interface for simplicity; separating them would add complexity
//   without proportional benefit. Test mocks should return nil/valid defaults for these.
type WeightOracle interface {
    // Weight returns the external weight for the given account/key at the given balance round.
    // The weight is defined at the balance snapshot, independent of vote round.
    // Returns an error if the daemon is unavailable or returns an error response.
    // Per protocol requirements, the returned weight MUST be > 0 for eligible participants.
    Weight(balanceRound basics.Round, addr basics.Address, selectionID crypto.VRFVerifier) (uint64, error)
    
    // TotalWeight returns the total external weight over the circulation population
    // defined by Circulation(balanceRound, voteRound) / OnlineCirculation(balanceRound, voteRound),
    // including protocol-flag and round-0 special cases (see §1.2 for exact rules).
    // This MUST succeed (or deterministically fail) for any historical round combination
    // needed by consensus logic. The daemon guarantees historical availability.
    // Returns an error if the daemon is unavailable or returns an error response.
    // Per protocol requirements, the returned total MUST be > 0 when circulation population is non-empty.
    TotalWeight(balanceRound basics.Round, voteRound basics.Round) (uint64, error)
    
    // Ping performs a connectivity check to the daemon.
    // STARTUP-ONLY: Must not be called from agreement/eval/ledger runtime paths.
    Ping() error
    
    // Identity returns the daemon's identity metadata for validation.
    // STARTUP-ONLY: Must not be called from agreement/eval/ledger runtime paths.
    Identity() (DaemonIdentity, error)
}

// DaemonIdentity contains metadata returned by the daemon for validation.
type DaemonIdentity struct {
    GenesisHash      crypto.Digest // Genesis block hash (identifies the chain)
    ProtocolVersion  string        // Daemon protocol version
    AlgorithmVersion string        // Weight algorithm version
}
```

### 4.3 Implement Weight Oracle Client

**File:** `node/weightoracle/client.go` (new package)

```go
package weightoracle

import (
    "container/list"
    "encoding/base64"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "net"
    "strconv"
    "sync"
    "time"
    
    "github.com/algorand/go-algorand/crypto"
    "github.com/algorand/go-algorand/data/basics"
    "github.com/algorand/go-algorand/ledger/ledgercore"
)

const (
    // Cache size limits - bounded to prevent unbounded memory growth
    maxWeightCacheSize      = 10000
    maxTotalWeightCacheSize = 1000
    
    // Network timeouts
    dialTimeout  = 5 * time.Second
    queryTimeout = 10 * time.Second
)

// Client implements ledgercore.WeightOracle by querying an external daemon.
type Client struct {
    port uint16
    
    // Bounded LRU caches with mutex protection
    // Note: We use sync.Mutex (not RWMutex) because LRU get() operations
    // mutate the recency list, making them writes rather than reads.
    weightMu    sync.Mutex
    weightCache *lruCache[cacheKey, uint64]
    
    totalMu    sync.Mutex
    totalCache *lruCache[totalCacheKey, uint64]
}

type cacheKey struct {
    addr         basics.Address
    selectionID  crypto.VRFVerifier
    balanceRound basics.Round
}

type totalCacheKey struct {
    balanceRound basics.Round
    voteRound    basics.Round
}

// Wire format structs use strings for all values (including numerics for portability).
// Note: Fields use omitempty so that request types only include their required fields.
type weightRequest struct {
    Type         string `json:"type"`
    Address      string `json:"address,omitempty"`       // base32 Algorand address
    SelectionID  string `json:"selection_id,omitempty"`  // hex-encoded 32-byte VRF key
    BalanceRound string `json:"balance_round,omitempty"` // decimal string
    VoteRound    string `json:"vote_round,omitempty"`    // decimal string (total_weight only)
}

type weightResponse struct {
    Weight      string `json:"weight,omitempty"`       // decimal string
    TotalWeight string `json:"total_weight,omitempty"` // decimal string
    Error       string `json:"error,omitempty"`
    Code        string `json:"code,omitempty"`
}

type identityResponse struct {
    GenesisHash      string `json:"genesis_hash"`      // base64-encoded
    ProtocolVersion  string `json:"protocol_version"`
    AlgorithmVersion string `json:"algorithm_version"`
    Error            string `json:"error,omitempty"`
    Code             string `json:"code,omitempty"`
}

func NewClient(port uint16) *Client {
    return &Client{
        port:        port,
        weightCache: newLRUCache[cacheKey, uint64](maxWeightCacheSize),
        totalCache:  newLRUCache[totalCacheKey, uint64](maxTotalWeightCacheSize),
    }
}

func (c *Client) Weight(balanceRound basics.Round, addr basics.Address, selID crypto.VRFVerifier) (uint64, error) {
    key := cacheKey{addr: addr, selectionID: selID, balanceRound: balanceRound}
    
    c.weightMu.Lock()
    if w, ok := c.weightCache.get(key); ok {
        c.weightMu.Unlock()
        return w, nil
    }
    c.weightMu.Unlock()
    
    resp, err := c.query(weightRequest{
        Type:         "weight",
        Address:      addr.String(),
        SelectionID:  hex.EncodeToString(selID[:]),
        BalanceRound: strconv.FormatUint(uint64(balanceRound), 10),
    })
    if err != nil {
        return 0, fmt.Errorf("weight query failed for addr=%s selID=%x balanceRound=%d: %w", 
            addr, selID[:8], balanceRound, err)
    }
    
    if resp.Error != "" || resp.Code != "" {
        return 0, &ledgercore.DaemonError{
            Code: resp.Code,
            Msg:  fmt.Sprintf("weight query (addr=%s selID=%x balanceRound=%d): %s", 
                addr, selID[:8], balanceRound, resp.Error),
        }
    }
    
    weight, err := strconv.ParseUint(resp.Weight, 10, 64)
    if err != nil {
        return 0, fmt.Errorf("invalid weight response for addr=%s: %w", addr, err)
    }
    
    c.weightMu.Lock()
    c.weightCache.put(key, weight)
    c.weightMu.Unlock()
    
    return weight, nil
}

func (c *Client) TotalWeight(balanceRound basics.Round, voteRound basics.Round) (uint64, error) {
    key := totalCacheKey{balanceRound: balanceRound, voteRound: voteRound}
    
    c.totalMu.Lock()
    if w, ok := c.totalCache.get(key); ok {
        c.totalMu.Unlock()
        return w, nil
    }
    c.totalMu.Unlock()
    
    resp, err := c.query(weightRequest{
        Type:         "total_weight",
        BalanceRound: strconv.FormatUint(uint64(balanceRound), 10),
        VoteRound:    strconv.FormatUint(uint64(voteRound), 10),
    })
    if err != nil {
        return 0, fmt.Errorf("total_weight query failed for balanceRound=%d voteRound=%d: %w", 
            balanceRound, voteRound, err)
    }
    
    if resp.Error != "" || resp.Code != "" {
        return 0, &ledgercore.DaemonError{
            Code: resp.Code,
            Msg:  fmt.Sprintf("total_weight query (balanceRound=%d voteRound=%d): %s", 
                balanceRound, voteRound, resp.Error),
        }
    }
    
    totalWeight, err := strconv.ParseUint(resp.TotalWeight, 10, 64)
    if err != nil {
        return 0, fmt.Errorf("invalid total_weight response: %w", err)
    }
    
    c.totalMu.Lock()
    c.totalCache.put(key, totalWeight)
    c.totalMu.Unlock()
    
    return totalWeight, nil
}

func (c *Client) Ping() error {
    conn, err := net.DialTimeout("tcp", fmt.Sprintf("127.0.0.1:%d", c.port), dialTimeout)
    if err != nil {
        return fmt.Errorf("cannot connect to weight daemon: %w", err)
    }
    defer conn.Close()
    
    if err := conn.SetDeadline(time.Now().Add(queryTimeout)); err != nil {
        return fmt.Errorf("set deadline failed: %w", err)
    }
    
    req := weightRequest{Type: "ping"}
    if err := json.NewEncoder(conn).Encode(req); err != nil {
        return fmt.Errorf("encode ping request: %w", err)
    }
    
    var resp struct {
        Pong  bool   `json:"pong"`
        Error string `json:"error,omitempty"`
        Code  string `json:"code,omitempty"`
    }
    if err := json.NewDecoder(conn).Decode(&resp); err != nil {
        return fmt.Errorf("decode ping response: %w", err)
    }
    
    if resp.Error != "" || resp.Code != "" {
        return fmt.Errorf("ping failed: %s (code: %s)", resp.Error, resp.Code)
    }
    if !resp.Pong {
        return fmt.Errorf("ping response missing pong=true")
    }
    
    return nil
}

func (c *Client) Identity() (ledgercore.DaemonIdentity, error) {
    conn, err := net.DialTimeout("tcp", fmt.Sprintf("127.0.0.1:%d", c.port), dialTimeout)
    if err != nil {
        return ledgercore.DaemonIdentity{}, fmt.Errorf("dial failed: %w", err)
    }
    defer conn.Close()
    
    if err := conn.SetDeadline(time.Now().Add(queryTimeout)); err != nil {
        return ledgercore.DaemonIdentity{}, fmt.Errorf("set deadline failed: %w", err)
    }
    
    req := weightRequest{Type: "identity"}
    if err := json.NewEncoder(conn).Encode(req); err != nil {
        return ledgercore.DaemonIdentity{}, fmt.Errorf("encode request: %w", err)
    }
    
    var resp identityResponse
    if err := json.NewDecoder(conn).Decode(&resp); err != nil {
        return ledgercore.DaemonIdentity{}, fmt.Errorf("decode response: %w", err)
    }
    
    if resp.Error != "" || resp.Code != "" {
        return ledgercore.DaemonIdentity{}, &ledgercore.DaemonError{
            Code: resp.Code,
            Msg:  fmt.Sprintf("identity query: %s", resp.Error),
        }
    }
    
    var identity ledgercore.DaemonIdentity
    genesisBytes, err := base64.StdEncoding.DecodeString(resp.GenesisHash)
    if err != nil {
        return ledgercore.DaemonIdentity{}, fmt.Errorf("invalid genesis hash encoding: %w", err)
    }
    if len(genesisBytes) != len(identity.GenesisHash) {
        return ledgercore.DaemonIdentity{}, fmt.Errorf("invalid genesis hash length: got %d, expected %d", 
            len(genesisBytes), len(identity.GenesisHash))
    }
    copy(identity.GenesisHash[:], genesisBytes)
    identity.ProtocolVersion = resp.ProtocolVersion
    identity.AlgorithmVersion = resp.AlgorithmVersion
    
    return identity, nil
}

func (c *Client) query(req weightRequest) (*weightResponse, error) {
    conn, err := net.DialTimeout("tcp", fmt.Sprintf("127.0.0.1:%d", c.port), dialTimeout)
    if err != nil {
        return nil, fmt.Errorf("dial failed: %w", err)
    }
    defer conn.Close()
    
    if err := conn.SetDeadline(time.Now().Add(queryTimeout)); err != nil {
        return nil, fmt.Errorf("set deadline failed: %w", err)
    }
    
    if err := json.NewEncoder(conn).Encode(req); err != nil {
        return nil, fmt.Errorf("encode request: %w", err)
    }
    
    var resp weightResponse
    if err := json.NewDecoder(conn).Decode(&resp); err != nil {
        return nil, fmt.Errorf("decode response: %w", err)
    }
    
    return &resp, nil
}

// Simple bounded LRU cache implementation
type lruCache[K comparable, V any] struct {
    capacity int
    items    map[K]*list.Element
    order    *list.List
}

type lruEntry[K comparable, V any] struct {
    key   K
    value V
}

func newLRUCache[K comparable, V any](capacity int) *lruCache[K, V] {
    return &lruCache[K, V]{
        capacity: capacity,
        items:    make(map[K]*list.Element),
        order:    list.New(),
    }
}

// get retrieves a value and updates recency. Caller must hold the mutex.
func (c *lruCache[K, V]) get(key K) (V, bool) {
    if elem, ok := c.items[key]; ok {
        c.order.MoveToFront(elem)
        return elem.Value.(*lruEntry[K, V]).value, true
    }
    var zero V
    return zero, false
}

// put adds or updates a value. Caller must hold the mutex.
func (c *lruCache[K, V]) put(key K, value V) {
    if elem, ok := c.items[key]; ok {
        c.order.MoveToFront(elem)
        elem.Value.(*lruEntry[K, V]).value = value
        return
    }
    
    if c.order.Len() >= c.capacity {
        oldest := c.order.Back()
        if oldest != nil {
            c.order.Remove(oldest)
            delete(c.items, oldest.Value.(*lruEntry[K, V]).key)
        }
    }
    
    entry := &lruEntry[K, V]{key: key, value: value}
    elem := c.order.PushFront(entry)
    c.items[key] = elem
}
```

**Implementation notes:**

- **Bounded caches:** LRU caches with fixed size limits prevent unbounded memory growth. The daemon is authoritative; the client cache is purely a performance optimization.
- **Mutex (not RWMutex):** `sync.Mutex` is used because LRU `get()` calls `MoveToFront()`, which mutates the internal list. `RWMutex` with `RLock()` would allow concurrent reads to race on list pointers.
- **Timeouts:** All network operations use explicit timeouts to prevent indefinite blocking.
- **Typed error responses:** The client returns `*ledgercore.DaemonError` for daemon error responses, preserving the error `Code`. Callers use `errors.As` or `ledgercore.IsDaemonError()` to branch on error type.

### 4.4 Inject Oracle into Ledger

**File:** `ledger/ledger.go`

```go
type Ledger struct {
    // ... existing fields ...
    
    weightOracle ledgercore.WeightOracle  // injected by node, required for operation
}

func (l *Ledger) SetWeightOracle(oracle ledgercore.WeightOracle) {
    l.weightOracle = oracle
}

// WeightOracle returns the configured weight oracle.
// Panics if no oracle is configured (indicates startup validation failure).
func (l *Ledger) WeightOracle() ledgercore.WeightOracle {
    if l.weightOracle == nil {
        logging.Base().Panicf("WeightOracle called but no oracle configured")
    }
    return l.weightOracle
}
```

**File:** `node/node.go` (at initialization)

```go
func (node *AlgorandFullNode) Start() error {
    // ... existing initialization ...
    
    // Weight oracle is REQUIRED - validate configuration and connectivity
    if node.config.ExternalWeightOraclePort == 0 {
        return fmt.Errorf("ExternalWeightOraclePort must be configured; this is a weighted-selection network")
    }
    
    oracle := weightoracle.NewClient(node.config.ExternalWeightOraclePort)
    
    if err := oracle.Ping(); err != nil {
        return fmt.Errorf("weight oracle connectivity check failed: %w", err)
    }
    
    identity, err := oracle.Identity()
    if err != nil {
        return fmt.Errorf("weight oracle identity check failed: %w", err)
    }
    
    if identity.GenesisHash != node.genesisHash {
        return fmt.Errorf("weight oracle genesis hash mismatch: expected %x, got %x", 
            node.genesisHash, identity.GenesisHash)
    }
    
    if identity.AlgorithmVersion != ledgercore.ExpectedWeightAlgorithmVersion {
        return fmt.Errorf("weight oracle algorithm version mismatch: expected %q, got %q",
            ledgercore.ExpectedWeightAlgorithmVersion, identity.AlgorithmVersion)
    }
    
    if identity.ProtocolVersion != ledgercore.ExpectedWeightProtocolVersion {
        return fmt.Errorf("weight oracle protocol version mismatch: expected %q, got %q",
            ledgercore.ExpectedWeightProtocolVersion, identity.ProtocolVersion)
    }
    
    node.ledger.SetWeightOracle(oracle)
    
    // Validate weights for local participation keys (see Section 4.11)
    if err := node.validateParticipationKeyWeights(oracle); err != nil {
        return fmt.Errorf("participation key weight validation failed: %w", err)
    }
    
    // ...
}
```

### 4.5 Define Required ExternalWeighter Interface

**Design principle:** To minimize changes to existing code, we define a **separate interface** rather than adding methods to `LedgerReader`. Code that needs external weights performs a type assertion. Failure to satisfy this interface is a **fatal error**—the node cannot operate without weight support.

**File:** `ledger/ledgercore/externalweighter.go` (new file)

**Rationale for ledgercore location:** Placing `ExternalWeighter` in `ledgercore` (rather than `agreement`) avoids import cycle issues. The `ledger/eval` package needs this interface for absenteeism calculations, and `ledger/eval` should not import `agreement`. Both `agreement` and `ledger/eval` already import `ledgercore`, making it the natural home for this shared interface.

```go
package ledgercore

import (
    "github.com/algorand/go-algorand/crypto"
    "github.com/algorand/go-algorand/data/basics"
)

// ExternalWeighter is a required interface that ledger implementations
// must satisfy for weighted committee selection. Use type assertion to access:
//
//     ew, ok := l.(ExternalWeighter)
//     if !ok {
//         // Fatal error: weighted network requires ExternalWeighter support
//         logging.Base().Panicf("...")
//     }
//
// This is a weighted-selection network; all nodes must have weight support.
type ExternalWeighter interface {
    // ExternalWeight returns the external weight for the given account/key
    // at the given balance round. Per protocol requirements, this MUST return > 0
    // for eligible participants.
    ExternalWeight(balanceRound basics.Round, addr basics.Address, selectionID crypto.VRFVerifier) (uint64, error)
    
    // TotalExternalWeight returns the total external weight over the circulation
    // population defined by Circulation(balanceRound, voteRound) / OnlineCirculation(balanceRound, voteRound),
    // including protocol-flag and round-0 special cases (see §1.2 for exact rules).
    // Per protocol requirements, this MUST return > 0 when circulation population is non-empty.
    TotalExternalWeight(balanceRound basics.Round, voteRound basics.Round) (uint64, error)
}
```

### 4.6 Modify Credential Verification

**File:** `data/committee/credential.go`

Replace the current sortition call:

```go
// CURRENT CODE:
if m.TotalMoney.Raw < userMoney.Raw {
    logging.Base().Panicf("UnauthenticatedCredential.Verify: total money = %v, but user money = %v", m.TotalMoney, userMoney)
} else if m.TotalMoney.IsZero() || expectedSelection == 0 || expectedSelection > float64(m.TotalMoney.Raw) {
    logging.Base().Panicf("UnauthenticatedCredential.Verify: m.TotalMoney %v, expectedSelection %v", m.TotalMoney.Raw, expectedSelection)
} else if !userMoney.IsZero() {
    weight = sortition.Select(userMoney.Raw, m.TotalMoney.Raw, expectedSelection, sortition.Digest(h))
}
```

With:

```go
// NEW CODE:
// Weight determines both eligibility and selection probability.
// Stake plays no role. Weight goes directly to sortition using the same binomial mechanism.
//
// The existing `userMoney := m.Record.VotingStake()` assignment earlier in this function
// is now unused for gating or selection. Suppress the Go unused-variable error:
_ = userMoney
//
// ExternalWeight == 0 means either:
//   (a) The account had invalid vote keys (membership() left weights at zero), or
//   (b) An invariant violation occurred (should have been caught in membership()).
// In case (a), vote.verify will reject the message immediately afterward.
// In case (b), we skip selection rather than panic here, since membership() is
// responsible for the non-zero invariant.
if m.ExternalWeight > 0 {
    // Validate weight invariants (population alignment check)
    if m.TotalExternalWeight < m.ExternalWeight {
        logging.Base().Panicf("UnauthenticatedCredential.Verify: TotalExternalWeight %d < ExternalWeight %d (population alignment violated)",
            m.TotalExternalWeight, m.ExternalWeight)
    }
    
    // Validate weight values for sortition
    if m.TotalExternalWeight == 0 || expectedSelection == 0 || expectedSelection > float64(m.TotalExternalWeight) {
        logging.Base().Panicf("UnauthenticatedCredential.Verify: TotalExternalWeight %d, expectedSelection %v",
            m.TotalExternalWeight, expectedSelection)
    }
    
    // Weight passed directly to sortition.Select — same binomial mechanism,
    // just weight instead of stake as the money/totalMoney arguments.
    // Selection probability = accountWeight / totalWeight
    weight = sortition.Select(m.ExternalWeight, m.TotalExternalWeight, expectedSelection, sortition.Digest(h))
}
```

**Unused `userMoney` note:** The existing `Verify()` function computes `userMoney := m.Record.VotingStake()` before the replaced block. Since stake no longer plays any role, this variable is unused. The `_ = userMoney` suppression is preferred over removing the assignment entirely because: (a) it preserves a minimal diff, (b) `VotingStake()` has no side effects so the call is harmless, and (c) removing it would require also removing the `expectedSelection`computation that currently appears between `userMoney` and the replaced block, which is still needed. Alternatively, the entire `userMoney` assignment line may be removed if desired — this is a cosmetic choice, not a behavioral one.

**Key differences from DD 3.15:**

1. **No `ComputeEffective`.** Weight values are passed directly to `sortition.Select`.
2. **Invariant checks use weight, not stake.** The `expectedSelection > float64(total)` check now validates against `TotalExternalWeight`.
3. **Stake plays no role.** The original `!userMoney.IsZero()` stake gate is removed. Eligibility is gated on `m.ExternalWeight > 0`, which is set by `membership()` for accounts with valid vote keys.
4. **No overflow risk from combining stake + weight.** Since we're not adding two large numbers, the only constraint is that weight values themselves fit in `uint64`.
5. **Same sortition function call.** The `sortition.Select` function is called identically — same binomial CDF walk — we just pass different values for the first two arguments.

### 4.7 Modify Membership Construction

**File:** `agreement/selector.go`

The existing `membership()` function (approximately line 68) constructs `committee.Membership` values. Modify it to also fetch and include external weights. **Critical:** Weight queries must be gated on vote-key validity to prevent network-triggerable panics (see §3.2).

**Required imports to add:**

```go
import (
    "errors"
    
    "github.com/algorand/go-algorand/ledger/ledgercore"
    "github.com/algorand/go-algorand/logging"
)
func membership(l LedgerReader, addr basics.Address, r basics.Round, p period, s step) (m committee.Membership, err error) {
    cparams, err := l.ConsensusParams(ParamsRound(r))
    if err != nil {
        return
    }
    balanceRound := BalanceRound(r, cparams)
    seedRound := seedRound(r, cparams)

    record, err := l.LookupAgreement(balanceRound, addr)
    if err != nil {
        err = fmt.Errorf("membership (r=%d): Failed to obtain balance record for address %v in round %d: %w", r, addr, balanceRound, err)
        return
    }

    total, err := l.Circulation(balanceRound, r)
    if err != nil {
        err = fmt.Errorf("membership (r=%d): Failed to obtain total circulation in round %d: %v", r, balanceRound, err)
        return
    }

    seed, err := l.Seed(seedRound)
    if err != nil {
        err = fmt.Errorf("membership (r=%d): Failed to obtain seed in round %d: %v", r, seedRound, err)
        return
    }

    m.Record = committee.BalanceRecord{OnlineAccountData: record, Addr: addr}
    m.Selector = selector{Seed: seed, Round: r, Period: p, Step: s}
    m.TotalMoney = total
    
    // CRITICAL: Gate weight queries on vote-key validity (see §3.2).
    // membership() is called BEFORE vote-key validity checks in vote.go,
    // so we may receive messages from accounts with expired/invalid keys.
    // Without this check, we would panic on valid daemon responses for ineligible accounts.
    keyEligible := (r >= record.VoteFirstValid) && (record.VoteLastValid == 0 || r <= record.VoteLastValid)
    
    if !keyEligible {
        // Leave ExternalWeight and TotalExternalWeight as zero.
        // vote.verify will reject this message immediately afterward
        // based on the same key validity check.
        return m, nil
    }
    
    // Fetch external weights - REQUIRED for this weighted-selection network
    // Only reached for accounts with valid vote keys at round r.
    ew, ok := l.(ledgercore.ExternalWeighter)
    if !ok {
        // This is a local invariant violation: startup should have validated oracle configuration.
        logging.Base().Panicf("membership (r=%d): weighted network requires ExternalWeighter support", r)
    }
    
    m.ExternalWeight, err = ew.ExternalWeight(balanceRound, addr, record.SelectionID)
    if err != nil {
        // Check error type: not_found/bad_request/unsupported are invariant violations
        // (we only query for key-eligible participants per §3.2), internal is operational
        var de *ledgercore.DaemonError
        if errors.As(err, &de) && de.Code != "internal" {
            // not_found, bad_request, unsupported → invariant violation
            logging.Base().Panicf("membership (r=%d): daemon invariant violation for addr %v: %v", r, addr, err)
        }
        // internal or network error → return error for operational handling
        err = fmt.Errorf("membership (r=%d): Failed to obtain external weight for address %v: %w", r, addr, err)
        return
    }
    
    m.TotalExternalWeight, err = ew.TotalExternalWeight(balanceRound, r)
    if err != nil {
        var de *ledgercore.DaemonError
        if errors.As(err, &de) && de.Code != "internal" {
            logging.Base().Panicf("membership (r=%d): daemon invariant violation for total weight: %v", r, err)
        }
        err = fmt.Errorf("membership (r=%d): Failed to obtain total external weight: %w", r, err)
        return
    }
    
    // Validate non-zero weight requirements per protocol spec.
    if m.ExternalWeight == 0 {
        logging.Base().Panicf("membership (r=%d): eligible participant %v has zero weight (invalid daemon state)", r, addr)
    }
    if m.TotalExternalWeight == 0 {
        logging.Base().Panicf("membership (r=%d): total weight is zero (invalid daemon state)", r)
    }
    
    // Validate population alignment: total must include this account's weight
    if m.TotalExternalWeight < m.ExternalWeight {
        logging.Base().Panicf("membership (r=%d): TotalExternalWeight %d < ExternalWeight %d (population alignment violated)", 
            r, m.TotalExternalWeight, m.ExternalWeight)
    }
    
    return m, nil
}
```

**Note:** The `LedgerReader` interface is **not modified**. Weight support is accessed via type assertion on `ExternalWeighter`. Only `internal` daemon errors and network failures are returned as errors; all other daemon errors and invariant violations are panics.

### 4.8 Implement ExternalWeighter in Ledger

**File:** `ledger/ledger.go`

```go
// ExternalWeight implements ledgercore.ExternalWeighter.
func (l *Ledger) ExternalWeight(balanceRound basics.Round, addr basics.Address, selID crypto.VRFVerifier) (uint64, error) {
    if l.weightOracle == nil {
        logging.Base().Panicf("ExternalWeight called but no oracle configured")
    }
    return l.weightOracle.Weight(balanceRound, addr, selID)
}

// TotalExternalWeight implements ledgercore.ExternalWeighter.
func (l *Ledger) TotalExternalWeight(balanceRound basics.Round, voteRound basics.Round) (uint64, error) {
    if l.weightOracle == nil {
        logging.Base().Panicf("TotalExternalWeight called but no oracle configured")
    }
    return l.weightOracle.TotalWeight(balanceRound, voteRound)
}
```

### 4.9 Suspension Logic Modification

**File:** `ledger/eval/eval.go`

The absenteeism detection must use weight values for expected proposal intervals. This requires modifying **both** the generation path (block building) and the validation path (block verification) to use the same weight-based criterion.

#### 4.9.1 Architecture Overview

In the current codebase, absenteeism checking uses a shared function:

```go
func isAbsent(totalOnlineStake basics.MicroAlgos, acctStake basics.MicroAlgos, lastSeen basics.Round, current basics.Round) bool
```

This function is called from **two places**:

1. `generateKnockOfflineAccountsList()` — block **generation** (when `eval.generate == true`)
2. `validateAbsentOnlineAccounts()` — block **validation** (when `eval.validate == true`)

**CRITICAL:** Both paths MUST use identical absence criteria. If you change one without the other, blocks will fail validation or nodes will diverge on what they accept.

#### 4.9.2 New `isAbsentByWeight` Function

Create a new function that takes weight values directly (no stake involved):

```go
// NOTE: The existing eval.go has a local `const absentFactor = 20`.
// We consolidate this with the new ledgercore.AbsenteeismMultiplier constant
// to prevent drift. The existing absentFactor can be replaced with an import
// of ledgercore.AbsenteeismMultiplier.

// isAbsentByWeight checks if an account should be considered absent using
// weight-based expected proposal intervals instead of stake-based intervals.
//
// Callers MUST enforce acctWeight > 0 before calling (see §4.9.4 and §4.9.5).
// The acctWeight == 0 guard below is a defensive fallback matching the existing
// isAbsent behavior; it should never be reached in correct operation.
func isAbsentByWeight(totalWeight uint64, acctWeight uint64, lastSeen basics.Round, current basics.Round) bool {
    // Don't consider accounts that were online when payouts went into effect as
    // absent. They get noticed the next time they propose or keyreg.
    if lastSeen == 0 || acctWeight == 0 {
        return false
    }
    // See if the account has exceeded their expected observation interval.
    // allowableLag = AbsenteeismMultiplier * totalWeight / acctWeight
    allowableLag, o := basics.Muldiv(ledgercore.AbsenteeismMultiplier, totalWeight, acctWeight)
    // Return false for overflow or a huge allowableLag.
    if o || allowableLag > math.MaxUint32 {
        return false
    }
    
    return lastSeen+basics.Round(allowableLag) < current
}
```

**Constant consolidation note:** The existing `ledger/eval/eval.go` defines `const absentFactor = 20`. To prevent drift and ensure consistency, either:

1. Replace `absentFactor` with an import of `ledgercore.AbsenteeismMultiplier`, or
2. Keep the local constant but add a compile-time assertion that it equals `ledgercore.AbsenteeismMultiplier`

#### 4.9.3 Required Imports

```go
import (
    "errors"
    "github.com/algorand/go-algorand/ledger/ledgercore"
    // Note: agreement import NOT needed because ExternalWeighter is in ledgercore
)
```

#### 4.9.3a Prerequisite: Expose `balanceRound()` via `roundCowParent` Interface

**Files:** `ledger/eval/cow.go`, `ledger/eval/eval.go`

The pseudocode in §4.9.4 and §4.9.5 calls `eval.state.balanceRound()`. However, `eval.state` is `*roundCowState`, which accesses its parent through the `roundCowParent` interface. The `balanceRound()` method is defined on `*roundCowBase` (in `eval.go`) but is **not** part of the `roundCowParent` interface (in `cow.go`). Since `roundCowState.lookupParent` is typed as `roundCowParent` (an interface field, not an embedded struct), `roundCowBase` methods are not promoted to `roundCowState`.

Without this change, `eval.state.balanceRound()` will not compile.

**Fix:** Add `balanceRound()` to the `roundCowParent` interface and add a delegation method on `roundCowState`:

```go
// cow.go — add to the roundCowParent interface
// (alongside the existing lookupAgreement and onlineStake methods):
balanceRound() (basics.Round, error)
```

```go
// cow.go — add delegation method on roundCowState
// (alongside the existing lookupAgreement delegation):
func (cb *roundCowState) balanceRound() (basics.Round, error) {
    return cb.lookupParent.balanceRound()
}
```

The existing `roundCowBase.balanceRound()` implementation (defined in `eval.go`) is unchanged. It computes `balanceRound` via `ParamsRound(current)` → block header → `config.Consensus[phdr.CurrentProtocol]` → `agreement.BalanceRound()`, which is the same recipe used by `onlineStake()` and `lookupAgreement()`.

**Why this pattern is correct:** The `roundCowParent` interface already includes `lookupAgreement()` and `onlineStake()`, both of which are implemented on `roundCowBase` and delegated by `roundCowState`. Adding `balanceRound()` follows exactly the same pattern. The existing `onlineStake()` and `lookupAgreement()` methods on `roundCowBase` already call `x.balanceRound()` internally, so this method is already exercised in the delegation chain — it is simply not yet directly callable from `roundCowState`.

#### 4.9.4 Modify Generation Path (`generateKnockOfflineAccountsList`)

The existing function signature is:

```go
func (eval *BlockEvaluator) generateKnockOfflineAccountsList(participating []basics.Address)
```

Note: This function is **void** (no return value) and modifies `eval.block.ParticipationUpdates` directly.

Key modifications needed:

1. **After getting `onlineStake`**, also get total weight. **Critical:** Assert on `eval.l` (the ledger), not `eval.state`(which is `roundCowState`). Also, compute `balanceRound` using the same method as `roundCowBase.balanceRound()` for consistency:

```go
    onlineStake, err := eval.state.onlineStake()
    if err != nil {
        logging.Base().Errorf("unable to fetch online stake, no knockoffs: %v", err)
        return
    }
    
    // NEW: Get total weight for weight-based absenteeism detection
    // CRITICAL: Assert on eval.l (the ledger), NOT eval.state (which is roundCowState)
    ew, ok := eval.l.(ledgercore.ExternalWeighter)
    if !ok {
        logging.Base().Panicf("generateKnockOfflineAccountsList: weighted network requires ExternalWeighter")
    }
    
    // Compute balance round using the SAME recipe as roundCowBase.balanceRound()
    // to ensure weight queries use the same balance round as stake queries.
    balanceRound, err := eval.state.balanceRound()
    if err != nil {
        logging.Base().Errorf("unable to compute balance round: %v", err)
        return
    }
    
    totalWeight, err := ew.TotalExternalWeight(balanceRound, current)
    if err != nil {
        var de *ledgercore.DaemonError
        if errors.As(err, &de) && de.Code != "internal" {
            logging.Base().Panicf("generateKnockOfflineAccountsList: daemon error for total weight: %v", err)
        }
        logging.Base().Errorf("unable to fetch total weight, no knockoffs: %v", err)
        return
    }
    
    // Sanity check: if onlineStake is non-zero but totalWeight is zero,
    // the daemon is inconsistent with the ledger's view of the online population.
    if !onlineStake.IsZero() && totalWeight == 0 {
        logging.Base().Panicf("generateKnockOfflineAccountsList: onlineStake=%v but totalWeight=0 (daemon population mismatch)", onlineStake)
    }
```

**Note on `onlineStake` usage:** After switching from `isAbsent()` to `isAbsentByWeight()`, `onlineStake` is no longer passed to the absence function. It is retained above for the cross-check against `totalWeight`. Without this (or assigning to `_`), Go will produce an "declared and not used" compilation error. The cross-check is preferred because it catches daemon/ledger population mismatches at runtime.

**Note:** `eval.state.balanceRound()` delegates through the `roundCowParent` interface to `roundCowBase.balanceRound()` (see §4.9.3a). It computes balanceRound via `ParamsRound(current)` → block header → `config.Consensus[phdr.CurrentProtocol]` → `agreement.BalanceRound()`. This ensures consistency with how `onlineStake()` and `lookupAgreement()` compute their balance rounds.

1. **In the loop over candidates**, get per-account weight:

```go
    // Inside the loop, after getting oad via lookupAgreement:
    accountWeight, err := ew.ExternalWeight(balanceRound, accountAddr, oad.SelectionID)
    if err != nil {
        var de *ledgercore.DaemonError
        if errors.As(err, &de) && de.Code != "internal" {
            logging.Base().Panicf("generateKnockOfflineAccountsList: daemon error for %v: %v", accountAddr, err)
        }
        logging.Base().Errorf("unable to fetch weight for %v: %v", accountAddr, err)
        continue
    }
    
    // Enforce non-zero weight invariant for accounts returned by GetKnockOfflineCandidates.
    // These accounts are online and in the circulation population, so the daemon must
    // return weight > 0 per §1.3. Zero here indicates a daemon bug.
    if accountWeight == 0 {
        logging.Base().Panicf("generateKnockOfflineAccountsList: zero weight for online account %v (daemon invariant violation)", accountAddr)
    }
```

1. **Replace the `isAbsent` call** with `isAbsentByWeight`:

```go
    // Replace:
    // if isAbsent(onlineStake, oad.VotingStake(), lastSeen, current) || ...
    // With:
    if isAbsentByWeight(totalWeight, accountWeight, lastSeen, current) ||
        ch.Failed(accountAddr, lastSeen) {
        // ... append to AbsentParticipationAccounts
    }
```

#### 4.9.5 Modify Validation Path (`validateAbsentOnlineAccounts`)

The same weight-based computation must be applied in the validation path. Key changes:

1. **After getting `totalOnlineStake`**, also get total weight. **Critical:** Assert on `eval.l` (not `eval.state`) and compute `balanceRound` using `eval.state.balanceRound()` for consistency with the generation path:

```go
    totalOnlineStake, err := eval.state.onlineStake()
    // ... existing error handling ...
    
    // NEW: Get total weight for weight-based absenteeism detection
    // CRITICAL: Assert on eval.l (the ledger), NOT eval.state
    ew, ok := eval.l.(ledgercore.ExternalWeighter)
    if !ok {
        return fmt.Errorf("weighted network requires ExternalWeighter support")
    }
    
    // Compute balance round using the SAME recipe as roundCowBase.balanceRound()
    // MUST match generation path exactly for consensus safety.
    balanceRound, err := eval.state.balanceRound()
    if err != nil {
        return fmt.Errorf("unable to compute balance round: %w", err)
    }
    
    totalWeight, err := ew.TotalExternalWeight(balanceRound, eval.Round())
    if err != nil {
        return fmt.Errorf("unable to fetch total weight: %w", err)
    }
    
    // Cross-check: same sanity check as generation path.
    // totalOnlineStake is retained for this check (otherwise unused after switching to weight-based absence).
    if !totalOnlineStake.IsZero() && totalWeight == 0 {
        return fmt.Errorf("totalOnlineStake=%v but totalWeight=0 (daemon population mismatch)", totalOnlineStake)
    }
    _ = totalOnlineStake // suppress "declared and not used" if cross-check is removed
```

**Note on `totalOnlineStake` usage:** Same as the generation path — after switching to `isAbsentByWeight()`, `totalOnlineStake` is no longer passed to the absence function. It is retained for the cross-check against `totalWeight`. The `_ = totalOnlineStake` assignment is a safety net to prevent compilation errors if the cross-check is ever removed.

1. **In the loop**, get per-account weight and use `isAbsentByWeight`:

```go
    // After getting oad via lookupAgreement:
    accountWeight, err := ew.ExternalWeight(balanceRound, accountAddr, oad.SelectionID)
    if err != nil {
        return fmt.Errorf("unable to fetch weight for %v: %w", accountAddr, err)
    }
    
    // Enforce non-zero weight invariant (same as generation path).
    if accountWeight == 0 {
        return fmt.Errorf("zero weight for online account %v in absent validation (daemon invariant violation)", accountAddr)
    }
    
    // Replace isAbsent call:
    if isAbsentByWeight(totalWeight, accountWeight, acctData.LastSeen(), eval.Round()) {
        continue // ok, it's "normal absent"
    }
```

#### 4.9.6 Interface Implementation Note

In go-algorand, the evaluator holds references including `eval.l` (of type `LedgerForEvaluator`) and `eval.state` (of type `*roundCowState`). The type assertion `eval.l.(ledgercore.ExternalWeighter)` requires that the concrete ledger type implements the `ExternalWeighter` interface.

In production, `eval.l` is typically `*ledger.Ledger`. The `Ledger` type must implement `ExternalWeight` and `TotalExternalWeight` methods that forward to the configured weight oracle (see §4.8).

**Important:** Do NOT attempt to assert on `eval.state`—`roundCowState` does not implement ledger methods like `ExternalWeight`. The weight oracle is accessed through `eval.l`.

#### 4.9.7 Consensus Safety

**This is a consensus-critical change.** All nodes must:

1. Use identical weight values for absence computation
2. Use identical absence threshold logic (preserve the exact comparator from current code)
3. Apply the same criterion in both generation and validation paths

All overflow conditions and invariant violations use panics to ensure identical failure behavior across nodes.

### 4.10 Local Configuration

**File:** `config/localTemplate.go` (or `config/local_defaults.go` as appropriate for the codebase)

```go
type Local struct {
    // ... existing fields ...
    
    // ExternalWeightOraclePort is the TCP port on 127.0.0.1 for the weight oracle daemon.
    // This field is REQUIRED for node operation. A value of 0 will cause startup failure.
    // This is a weighted-selection network; all nodes must have a functioning oracle.
    ExternalWeightOraclePort uint16 `version[X]:"0"`
}
```

**Version tag:** Replace `X` with the next available version index. The current maximum version tag in `config/localTemplate.go` is **38**, and `config/local_defaults.go` sets `Version: 38`. Use version **39** for the new field, and update `local_defaults.go` accordingly.

After adding the field:

```bash
make generate
```

Also update test config fixtures as required by the config package documentation.

### 4.11 Startup Validation

**File:** `node/node.go` (participation key validation)

**API verification required:** The code below references several node and account APIs that may have changed. Before implementing, verify the following against the actual January 2026 go-algorand codebase:

- `node.ListParticipationKeys()` — verify method name and return type (expected: `[]account.ParticipationRecord`)
- `record.Account` — verify this field exists and is type `basics.Address`
- `record.VRF` — verify this field exists; check if it's a pointer, struct, or interface
- `record.VRF.PK` — verify this is the `crypto.VRFVerifier` (selection ID)
- `record.FirstValid`, `record.LastValid` — verify these fields exist with type `basics.Round`
- `snapshotData.SelectionID` — verify `LookupAgreement` returns a type with this field

```go
// validateParticipationKeyWeights verifies that all active local participation keys
// have non-zero weights for accounts that are actually eligible in the balance snapshot.
// This is a startup requirement for weighted-selection networks.
//
// This function respects the §3.2 operational invariant by only querying weights for
// accounts confirmed to be in the circulation population via LookupAgreement.
func (node *AlgorandFullNode) validateParticipationKeyWeights(oracle ledgercore.WeightOracle) error {
    // Use the same round computation recipe as agreement/selector.go::membership():
    //   voteRound    = the next round to be agreed upon
    //   cparams      = ConsensusParams(ParamsRound(voteRound))
    //   balanceRound = BalanceRound(voteRound, cparams)
    // This ensures we validate against the same snapshot agreement will use.
    voteRound := node.ledger.Latest() + 1
    cparams, err := node.ledger.ConsensusParams(agreement.ParamsRound(voteRound))
    if err != nil {
        return fmt.Errorf("failed to get consensus params for ParamsRound(%d): %w", voteRound, err)
    }
    balanceRound := agreement.BalanceRound(voteRound, cparams)
    
    partRecords, err := node.ListParticipationKeys()
    if err != nil {
        return fmt.Errorf("failed to list participation keys: %w", err)
    }
    
    for _, record := range partRecords {
        // Check if key is active for upcoming vote round based on local validity window
        if voteRound < record.FirstValid || voteRound > record.LastValid {
            continue // Key not valid for upcoming vote round, skip
        }
        
        // VRF must be non-nil for a valid participation record
        if record.VRF == nil {
            return fmt.Errorf("participation key for %v has nil VRF (invalid participation record)", record.Account)
        }
        
        // Check if this account is actually in the balance snapshot
        snapshotData, err := node.ledger.LookupAgreement(balanceRound, record.Account)
        if err != nil {
            // Account not found or not online in snapshot - skip
            continue
        }
        
        // Verify the local key's SelectionID matches the snapshot's SelectionID
        if snapshotData.SelectionID != record.VRF.PK {
            // Key doesn't match snapshot — skip
            continue
        }
        
        // Apply the same key-validity gating as membership() to determine
        // if this account is in the circulation population for the upcoming vote round.
        keyEligible := (voteRound >= snapshotData.VoteFirstValid) && (snapshotData.VoteLastValid == 0 || voteRound <= snapshotData.VoteLastValid)
        if !keyEligible {
            // Key is not eligible at voteRound per the snapshot's vote validity window.
            // This is normal: the local key may be installed but not yet reflected in
            // the balance snapshot, or the snapshot key may have a different validity window.
            continue
        }
        
        // Account is in circulation population and local key matches — query daemon for weight
        weight, err := oracle.Weight(balanceRound, record.Account, snapshotData.SelectionID)
        if err != nil {
            // At startup, treat all daemon errors as fatal
            return fmt.Errorf("failed to query weight for participation key %v: %w", record.Account, err)
        }
        
        if weight == 0 {
            return fmt.Errorf("participation key %v has zero weight; cannot participate in weighted-selection network", record.Account)
        }
    }
    
    return nil
}
```

**Startup validation summary:**

Before starting agreement / block validation services, the node performs these checks:

1. **Oracle configured:** `ExternalWeightOraclePort` must be non-zero
2. **Oracle reachable:** A basic connectivity check (`Ping()`) must succeed
3. **Oracle identity valid:** Genesis hash, algorithm version, and protocol version must all match expected values
4. **Participation key weights valid:** For each local participation key valid for the upcoming vote round (`Latest()+1`), where the account is present in the balance snapshot (verified via `LookupAgreement`) and the local key matches the snapshot's SelectionID and passes the same key-eligibility gating as `membership()`, query `weight(addr, selectionID, balanceRound)` and require `> 0`

If any check fails, the node refuses to start.

**Operational note on key eligibility:** A node may have locally "active" participation keys (valid `FirstValid`/`LastValid` window) that are not yet reflected in the balance snapshot due to lookback delay, or whose snapshot-level vote validity window does not include the upcoming vote round. These keys are skipped during startup validation. This is normal operation.

------

## 5. Consensus Safety Analysis

### 5.1 Determinism Guarantees

For consensus safety, all nodes must compute identical:

- `ExternalWeight` for each account (passed directly to `sortition.Select` as `money`)
- `TotalExternalWeight` for the network (passed directly to `sortition.Select` as `totalMoney`)
- Expected proposal intervals for suspension (computed from the same weight values)

This is guaranteed because:

1. **Daemon is authoritative:** All weight queries go to the daemon, which returns deterministic results based on on-chain data
2. **Same round pair:** Weight queries use the same `(balanceRound, voteRound)` parameters as stake queries
3. **Daemon persistence:** Historical queries return consistent results across restarts and catchpoints
4. **No stake/weight mixing:** The absence of a `ComputeEffective` function eliminates an entire class of potential determinism issues — there are no factor constants or arithmetic combinations that could diverge

### 5.2 Restart and Catchpoint Safety

**Process restart:**

- algod's cache is lost
- algod re-queries daemon for any needed `(addr, SelectionID, balanceRound)` and `(balanceRound, voteRound)`
- Daemon's persistent database provides identical answers

**Catchpoint/fast catchup:**

- Historical keyreg replay is skipped
- algod queries daemon for weights at any round combination needed during verification
- Daemon answers correctly regardless of algod's local history

### 5.3 Overflow Handling

Since weight values go directly to `sortition.Select` without being combined with stake, overflow is only possible if weight values themselves are pathologically large. The daemon's weight scheme must ensure `totalWeight` fits in `uint64`. This is a simpler constraint than DD 3.15's requirement that `(StakeFactor × totalStake + WeightFactor × totalWeight)` fit in `uint64`.

For absenteeism, the `AbsenteeismMultiplier × totalWeight / acctWeight` computation uses `basics.Muldiv`which handles overflow gracefully (returning overflow flag → function returns false → no suspension). This matches the existing `isAbsent` overflow behavior.

### 5.4 Oracle Failure Modes

If the daemon is unavailable:

- Weight lookups fail with an error
- Membership construction fails
- Agreement cannot proceed

This is expected behavior: daemon availability is an operational requirement for all nodes.

**Startup enforcement:** Nodes validate oracle connectivity, identity (including algorithm version and protocol version), and participation key weights at startup. A node with a misconfigured or unreachable oracle will not start.

**Runtime timeouts:** The oracle client uses explicit timeouts for all network operations. If the daemon becomes unresponsive, queries will fail with timeout errors rather than blocking indefinitely.

### 5.5 Weight Requirements

This is a weighted-selection network. The following requirements are enforced:

**At startup (fail-fast for misconfiguration):**

- Oracle port must be configured (`ExternalWeightOraclePort > 0`) — startup fails if not
- Oracle must be reachable (connectivity check) — startup fails if not
- Oracle genesis hash must match node's genesis hash — startup fails if not
- Oracle algorithm version must match `ExpectedWeightAlgorithmVersion` — startup fails if not
- Oracle protocol version must match `ExpectedWeightProtocolVersion` — startup fails if not
- All active participation keys with eligible accounts (per balance snapshot at the upcoming vote round) must have non-zero weights — startup fails if not

**At runtime (panic for invariant violations):**

- `ExternalWeighter` interface must be satisfied by the ledger — panic if not
- Daemon returns `not_found`/`bad_request`/`unsupported` for queries algod believes are valid — panic
- Individual weights must be non-zero for eligible participants — panic if zero
- Total weights must be non-zero when candidate population is non-empty — panic if zero
- Population alignment: `TotalExternalWeight >= ExternalWeight` for any account — panic if violated

**At runtime (return error for operational failures):**

- Daemon returns `internal` error — return error (daemon unhealthy, transient condition)
- Network errors, timeouts — return error (operational issue)

**There is no "no-weight" or "stake-only" operating mode.** Nodes cannot run without a functioning weight oracle.

**For unit testing:** Test code should provide mock implementations of `ExternalWeighter` that return appropriate non-zero weights.

------

## 6. Files Modified Summary

| File                                    | Change                                                       |
| --------------------------------------- | ------------------------------------------------------------ |
| `data/committee/committee.go`           | Add `ExternalWeight`, `TotalExternalWeight` fields to `Membership` |
| `data/committee/credential.go`          | Modify `UnauthenticatedCredential.Verify` to use weight for both eligibility and sortition |
| `ledger/ledgercore/externalweighter.go` | **New file:** `ExternalWeighter` required interface          |
| `ledger/ledgercore/weightoracle.go`     | **New file:** `WeightOracle` interface, `DaemonIdentity` struct, `DaemonError`type, version constants, `AbsenteeismMultiplier` |
| `agreement/selector.go`                 | Modify `membership()` to require `ExternalWeighter`, add key-validity gating before weight queries |
| `ledger/ledger.go`                      | Implement `ExternalWeight`, `TotalExternalWeight`, add `SetWeightOracle`, `WeightOracle` |
| `ledger/eval/eval.go`                   | Add `isAbsentByWeight()`, modify suspension logic in both generation and validation paths |
| `ledger/eval/cow.go`                    | Add `balanceRound()` to `roundCowParent` interface and `roundCowState` delegation |
| `node/weightoracle/client.go`           | **New file:** Oracle client with bounded LRU caches, timeouts, `Ping()`, `Identity()` |
| `node/node.go`                          | Inject oracle, startup validation (connectivity, identity, participation key weights) |
| `config/localTemplate.go`               | Add `ExternalWeightOraclePort` field (required)              |

**Files NOT modified:**

- `github.com/algorand/sortition` — external package unchanged; same binomial mechanism called with weight instead of stake
- `data/basics/userBalance.go` — no on-chain data structure changes
- `ledger/apply/keyreg.go` — no changes
- `agreement/abstractions.go` — **LedgerReader interface unchanged** (separate interface pattern)
- **Payout/reward code** — no changes; rewards flow proportional to weight via selection frequency

**Files REMOVED compared to DD 3.15:**

- `ledger/ledgercore/weighted.go` — **Not needed.** DD 3.15 used this for `StakeFactor`, `WeightFactor`, `ComputeEffective`, `ComputeAbsentThreshold`, and `RoundsSince`. In DD 4.0, weight goes directly to sortition with no transformation. The only constant needed (`AbsenteeismMultiplier`) is placed in `weightoracle.go`.

------

## 7. Testing Strategy

### 7.1 Unit Tests

- `ledger/ledgercore/weightoracle_test.go`: Test `DaemonError` type and `IsDaemonError()` helper
- `data/committee/credential_test.go`: Verify weight-based sortition (weight replaces stake in `Select` call), panic behavior preserved, weight invariant checks, weight-as-gate behavior (zero weight → not selected, regardless of stake)
- `agreement/*_test.go`: Verify `membership()` requires `ExternalWeighter`, implements key-validity gating, panics on invariant violations and non-operational daemon errors, returns errors on `internal` daemon errors
- `ledger/eval/eval_test.go`: Verify `isAbsentByWeight()` matches expected interval computation, verify both generation and validation paths use weight-based absence detection
- `node/weightoracle/client_test.go`: Mock daemon responses, test LRU cache eviction, verify wire format encoding/decoding, test `Ping()`, test `Identity()`, test timeout behavior, verify `*ledgercore.DaemonError` is returned for daemon errors

### 7.2 Integration Tests

- End-to-end committee selection with mock daemon returning non-zero weights
- Verify accounts with higher weight are selected proportionally more often
- Verify accounts with equal weight have equal selection probability regardless of stake balance
- Verify suspension logic uses weight-based intervals
- Verify suspension logic handles future `LastHeartbeat` correctly (no false absenteeism)
- Verify suspension logic returns empty list (not panic) when no candidates
- Test restart: clear algod cache, verify re-queries daemon correctly
- Test catchpoint catchup with daemon
- Verify cache size stays bounded during long replays
- Test that `(balanceRound, voteRound)` pairs are correctly threaded through all code paths
- Test startup failure when oracle not configured, unreachable, or identity mismatches
- Test startup validation skips ineligible keys (including snapshot key-validity gating), fails on zero-weight eligible keys
- Test runtime panic when `ExternalWeighter` returns zero weight or population alignment violated
- Test runtime error (not panic) when daemon returns `internal` error

### 7.3 Consensus Tests

- Multi-node network with identical daemon instances
- Verify all nodes select same committees
- Verify all nodes suspend same accounts
- Test daemon unavailability causes deterministic failure across all nodes
- Test daemon timeout behavior under load

------

## 8. Appendix: Call Graph

```
agreement/vote.go (or equivalent entry point)
    ↓
agreement/selector.go::membership(l, addr, r, p, s)
    ├─ l.LookupAgreement(balanceRound, addr) → OnlineAccountData
    ├─ l.Circulation(balanceRound, r) → TotalMoney  [retained for minimal diff; no longer used in credential verification]
    ├─ key-eligibility check: VoteFirstValid ≤ r ≤ VoteLastValid
    │   └─ if ineligible → return m with zero weights (vote.verify rejects)
    ├─ type assertion: l.(ExternalWeighter) — REQUIRED, panic if fails
    │   ├─ ew.ExternalWeight(balanceRound, addr, selID) → weight
    │   │       (panic if 0; panic if not_found/bad_request; error if internal)
    │   └─ ew.TotalExternalWeight(balanceRound, r) → totalWeight
    │           (panic if 0 or < weight; panic if not_found/bad_request; error if internal)
    │           ↓
    │       ledger/ledger.go::ExternalWeight / TotalExternalWeight
    │           └─ weightOracle.Weight / TotalWeight
    │                   ↓
    │               node/weightoracle/client.go → TCP to daemon (bounded LRU cache, timeouts)
    │                   └─ returns *ledgercore.DaemonError on daemon error responses
    │
    └─ returns Membership{Record, Selector, TotalMoney, ExternalWeight, TotalExternalWeight}
            ↓
data/committee/credential.go::UnauthenticatedCredential.Verify(proto, m)
    ├─ gate check: if m.ExternalWeight > 0               ← weight as eligibility gate
    ├─ validate: TotalExternalWeight >= ExternalWeight       ← population alignment
    ├─ validate: TotalExternalWeight > 0, etc.               ← weight invariants
    └─ sortition.Select(m.ExternalWeight, m.TotalExternalWeight, expectedSelection, digest)
            ↓ weight directly      ↑ weight directly
github.com/algorand/sortition::Select(money, totalMoney, expectedSize, vrfOutput)
    └─ returns weight (number of sub-user selections via same binomial CDF walk)
```

------

## 9. Appendix: Daemon Behavioral Requirements

The daemon is outside the scope of this algod design document, but must satisfy the following **normative behavioral requirements**:

1. **Query interface:** Answer queries keyed by `(addr, selectionID, balanceRound)` for individual weights and `(balanceRound, voteRound)` for total weights. Each request is a single JSON object over a new TCP connection; the daemon replies with a single JSON object and the connection is closed.
2. **Concurrency:** Support concurrent connections; algod may issue parallel lookups.
3. **Determinism:** Compute weights as a pure function of on-chain data.
4. **Completeness:** Answer queries for any historical round or round combination.
5. **Independence:** `totalWeight(balanceRound, voteRound)` must be computable without relying on algod to have previously queried individual weights at those rounds.
6. **Availability:** Be operational whenever algod needs to perform consensus operations.
7. **Consistency:** All daemon instances across the network must return identical results for identical queries.
8. **Population alignment:** The population used for `totalWeight(balanceRound, voteRound)` must exactly match the circulation population definition used by `OnlineCirculation(balanceRound, voteRound)` — see §1.2 for the exact rules including protocol version source, round-0 special case, and expired key condition.
9. **Non-zero weights:** Return `weight > 0` for all participants in the circulation population and `totalWeight > 0`when circulation population is non-empty.
10. **Identity endpoint:** Respond to `identity` queries with genesis hash, protocol version, and algorithm version.
11. **Error responses:** Use the standard error response format. Success and error fields are mutually exclusive. For valid consensus queries, must not return `"bad_request"` or `"unsupported"`.

**Non-normative implementation note:** Efficient storage via change-point / interval storage (not per-round storage) is recommended to enable efficient historical queries without unbounded growth (see §1.5).

------

## 10. Appendix: Implementation Verification Notes

### 10.1 Verified Package Paths

This document has been verified against the go-algorand repository (master branch, February 2026). DD 4.5 incorporates corrections based on source code review of `OnlineCirculation` semantics, agreement round computation, and absenteeism paths, requirements-alignment fixes from DD 4.1 review, implementation-tightening from DD 4.2 review, interface-comment corrections from DD 4.3 review, and the `roundCowParent` interface fix from DD 4.4 review.

**Confirmed package path:** The `ledgercore` package is at `ledger/ledgercore/` (not top level).

- **Import path:** `"github.com/algorand/go-algorand/ledger/ledgercore"`

New files proposed:

- `ledger/ledgercore/weightoracle.go`
- `ledger/ledgercore/externalweighter.go`

Related packages:

- `agreement/` — agreement protocol, `LedgerReader` interface, `membership()` function
- `data/committee/` — credential verification, sortition integration
- External `github.com/algorand/sortition` — sortition algorithm (unchanged)

### 10.2 Implementation Verification Checklist

| Item                          | Section     | What to Verify                                               |
| ----------------------------- | ----------- | ------------------------------------------------------------ |
| Membership construction sites | §4.1        | Search for BOTH `committee.Membership{...}` AND `Membership{...}` literals; update each |
| Circulation method name       | §1.2, §4.7  | Confirm `agreement.LedgerReader` uses `Circulation` or `OnlineCirculation` |
| OnlineCirculation signature   | §4.9        | Confirm evaluator interface uses two-round semantics         |
| Absenteeism comparator        | §4.9        | Verify existing code uses `>` or `>=` for threshold; match exactly |
| Participation key APIs        | §4.11       | Verify `ListParticipationKeys()`, `record.VRF`, `record.Account`, `agreement.ParamsRound`, etc. |
| Startup round computation     | §4.11       | Verify `voteRound = Latest()+1`, `ConsensusParams(ParamsRound(voteRound))`, `BalanceRound(voteRound, cparams)` matches agreement recipe |
| Config version tag            | §4.10       | Check current max version tag and use next value             |
| LookupAgreement return type   | §4.7, §4.11 | Verify return type has `SelectionID` and `VotingStake()`     |

------

## 11. Appendix: Comparison with DD 3.15

| Aspect                       | DD 3.15 (stake/weight mixing)                                | DD 4.5 (weight replaces stake)                            |
| ---------------------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| Sortition input `money`      | `ComputeEffective(userStake, userWeight)`                    | `userWeight` directly                                     |
| Sortition input `totalMoney` | `ComputeEffective(totalStake, totalWeight)`                  | `totalWeight` directly                                    |
| Stake role                   | Contributes to selection probability via factor              | No role in eligibility or selection                       |
| Weight role                  | Contributes to selection probability via factor              | Sole determinant of eligibility and selection probability |
| Constants needed             | `StakeFactor`, `WeightFactor`, `AbsenteeismMultiplier`       | `AbsenteeismMultiplier` only                              |
| New source files             | `weighted.go`, `weightoracle.go`, `externalweighter.go`      | `weightoracle.go`, `externalweighter.go`                  |
| Overflow risk                | `(StakeFactor × stake + WeightFactor × weight)`can overflow `uint64` | Only weight itself must fit in `uint64`                   |
| Absenteeism inputs           | `(effectiveAccount, effectiveTotal)` combining stake + weight | `(accountWeight, totalWeight)`directly                    |
| Reward proportionality       | Proportional to `effective = f(stake, weight)`               | Proportional to weight                                    |
| Sortition mechanism          | Same binomial CDF (unchanged)                                | Same binomial CDF (unchanged)                             |
| Sortition package changes    | None                                                         | None                                                      |
| Payout code changes          | None                                                         | None                                                      |
| Complexity                   | Higher — factor arithmetic, overflow checks                  | Lower — direct substitution                               |

------

## 12. Changelog: DD 4.4 → DD 4.5

### 12.1 Fix `eval.state.balanceRound()` Compilation Error (§4.9.3a, §4.9.4, §6, §10)

**Problem:** §4.9.4 and §4.9.5 call `eval.state.balanceRound()`, where `eval.state` is `*roundCowState`. However, `balanceRound()` is defined only on `*roundCowBase` (in `eval.go`) and is **not** part of the `roundCowParent` interface (in `cow.go`). Since `roundCowState` holds its parent via the `roundCowParent` interface (not as an embedded struct), `roundCowBase` methods are not promoted. The call `eval.state.balanceRound()` will not compile.

**Fix:**

- **§4.9.3a (new):** Added prerequisite section documenting the required change to `cow.go`: add `balanceRound()` to the `roundCowParent` interface and add a delegation method on `roundCowState`. This follows the existing pattern used by `lookupAgreement()` and `onlineStake()`, which are already in `roundCowParent` and delegated identically.
- **§4.9.4 note:** Updated the `eval.state.balanceRound()` note to describe the delegation chain through `roundCowParent` (replacing the incorrect claim that it is "an existing method on `roundCowBase`" — the implementation is on `roundCowBase`, but the call site is on `eval.state` which is `*roundCowState`).
- **§6 Files Modified:** Added `ledger/eval/cow.go` to the table.
- **§10.1:** Updated verification note to reference DD 4.5.

**Source:** `ledger/eval/cow.go` (`roundCowParent` interface definition), `ledger/eval/eval.go` (`roundCowBase.balanceRound()` implementation and `roundCowState` type).

------

## 13. Changelog: DD 4.3 → DD 4.4

### 13.1 Correct `TotalExternalWeight` / `TotalWeight` Interface Comments (§1.2, §4.2, §4.5)

**Problem:** The godoc comments on `WeightOracle.TotalWeight` (§4.2) and `ExternalWeighter.TotalExternalWeight` (§4.5) described the population as accounts "eligible for voting at voteRound." This is misleading because `OnlineCirculation(balanceRound, voteRound)` does not always correspond to "eligible for voting" — it depends on the `ExcludeExpiredCirculation` protocol flag and the round-0 special case. Implementers reading the interface comment could exclude a different population than `OnlineCirculation` actually counts.

**Fix:** Replaced "eligible for voting at voteRound" with explicit references to the circulation population as defined by `Circulation(balanceRound, voteRound)` / `OnlineCirculation(balanceRound, voteRound)`, including protocol-flag and round-0 special cases, with a cross-reference to §1.2 for exact rules. Also tightened the §1.2 motivational paragraph to avoid the same loose phrasing.

### 13.2 Tighten §3.2 Daemon Response Wording for Ineligible Senders

**Problem:** §3.2 stated the daemon "may legitimately return 0 or not_found" for ineligible senders without explicitly qualifying that this applies only to accounts **not in the circulation population**. Given the strict non-zero weight invariant for circulation participants, the unqualified wording could be misread as permitting zero weight for accounts that are in the circulation population but happen to have expired keys (which can occur when `ExcludeExpiredCirculation` is disabled).

**Fix:** Added "that are not in the circulation population" qualifier. Added a "Conversely" clause explicitly stating that if an expired-key account is still in the circulation population (due to protocol flags), the daemon must still return `weight > 0`.

### 13.3 Promote §1.3 Design Decision to "Protocol Choice" (§1.3)

**Problem:** The non-zero weight invariant's status as a deliberate protocol choice was documented in §1.3 but could be missed by readers scanning for protocol-level decisions.

**Fix:** Retitled from "Design decision note" to "Protocol choice — weight=0 is not a supported eligibility state" for visibility. Added explicit statement that weight=0 would need to be treated as "ineligible" if the invariant were ever relaxed.

------

## 14. Changelog: DD 4.2 → DD 4.3

### 14.1 Handle Unused `userMoney` Variable in Credential Verification (§4.6)

**Problem:** DD 4.2 removed the `!userMoney.IsZero()` stake gate and replaced it with `m.ExternalWeight > 0`, but the existing `userMoney := m.Record.VotingStake()` assignment earlier in the `Verify()` function body was left in place. Since `userMoney` is no longer referenced, Go will produce a compile-time "declared and not used" error.

**Fix:** Added `_ = userMoney` suppression to the new code block, with an explanatory note. The assignment is retained (rather than deleted) for minimal diff, and because `VotingStake()` is side-effect-free. Added a note that removing the assignment line entirely is also acceptable as a cosmetic choice.

### 14.2 Acknowledge Non-zero Weight Invariant as Design Decision (§1.3)

**Problem:** Review noted that the strict `weight > 0` invariant for all circulation population participants is a protocol design choice that precludes "zero-weight but online" accounts. This is intentional but was not explicitly acknowledged.

**Fix:** Added a "Design decision note" paragraph to §1.3 documenting that this is a deliberate choice, explaining what would need to change if a future weight scheme requires zero-weight online accounts, and confirming the current design does not support this.

------

## 15. Changelog: DD 4.1 → DD 4.2

### 15.1 Remove Stake as Eligibility Gate (Goal, §3.1, §3.3, §4.6, §8)

**Problem:** DD 4.1 retained `!userMoney.IsZero()` (non-zero stake) as an eligibility gate for committee selection and block proposal. This directly contradicted the requirement: "No stake is required for eligibility to serve on a committee or propose a block. Weight is."

**Fix:**

- **Goal statement:** Rewritten to state stake plays no role in eligibility or selection. Eligibility is determined by online status, key validity, and non-zero weight.
- **§3.1:** Replaced "Stake as eligibility gate only" paragraph with "Stake plays no role in eligibility or selection" paragraph. The original `!userMoney.IsZero()` check is removed.
- **§3.3:** Updated to state stake is not checked; eligibility is determined by online status, key validity, and non-zero weight.
- **§4.6 (credential verification):** The `if !userMoney.IsZero()` gate is replaced with `if m.ExternalWeight > 0`. This gates sortition on weight availability rather than stake balance. For key-eligible accounts, `membership()`guarantees `ExternalWeight > 0` (panics otherwise). For key-ineligible accounts, `membership()` leaves `ExternalWeight = 0`, and `vote.verify` rejects the message.
- **§8 (Call Graph):** Updated to show `m.ExternalWeight > 0` gate instead of `!userMoney.IsZero()`.

**Behavioral impact:** Accounts with non-zero weight and valid participation keys can now be selected for committees and block proposal regardless of their algo balance. Accounts with zero stake but non-zero external weight are now eligible participants.

**Source:** Requirements document: "No stake is required for eligibility to serve on a committee or propose a block. Weight is."

### 15.2 Mark Daemon Implementation Notes as Non-normative (§1.5, §9)

**Problem:** DD 4.1 included daemon implementation guidance (recommended storage model, efficient storage requirement) that went beyond "define behavior," which the requirements specify as the scope boundary.

**Fix:**

- §1.5: "Recommended storage model" and "Note on total weight storage" paragraphs are now prefixed with "Non-normative implementation note."
- §9: Renamed from "Daemon Implementation Notes" to "Daemon Behavioral Requirements." Separated normative behavioral requirements from non-normative implementation guidance. The efficient storage recommendation is moved to a non-normative note at the end.

### 15.3 Consistency Updates (§4.1, §6, §7, §10, §11)

**Problem:** After removing the stake eligibility gate, several other sections still referenced stake-as-gate behavior.

**Fix:**

- §4.1 `TotalMoney` note: Removed reference to stake gate.
- §6 Files Modified: Updated credential.go description.
- §7.1/§7.2 Tests: Updated test descriptions to reference weight-as-gate instead of stake-as-gate.
- §11 Comparison table: Updated "Stake role" row to "No role in eligibility or selection."

------

## 16. Changelog: DD 4.0 → DD 4.1

### 16.1 Fix `OnlineCirculation` Semantics (§1.2)

**Problem:** §1.2 incorrectly stated that `ExcludeExpiredCirculation` is determined by the protocol at `ParamsRound(voteRound)`. It also omitted the round-0 special case and the `VoteLastValid != 0` guard in the expired condition.

**Fix:** Rewrote the "Circulation population semantics (CRITICAL)" block to specify:

- `ExcludeExpiredCirculation` is checked using the protocol version at `balance_round`, not `vote_round`.
- When `balance_round == 0`, expired stake is never subtracted (genesis balance special case for first ~320 rounds).
- The expired condition is `VoteLastValid != 0 && VoteLastValid < vote_round` — accounts with `VoteLastValid == 0` (perpetual validity) are never subtracted.
- Added explicit "Early-round queries" note about `(balance_round=0, vote_round=...)` pairs.

**Source:** `ledger/acctonline.go`, `onlineCirculation()` function and `onlineAcctsExpiredByRound()` delta application logic.

### 16.2 Tighten Population Terminology (§1.2, §1.3, §3.2, throughout)

**Problem:** The term "eligible population" was used to describe the set of accounts counted by `OnlineCirculation(balanceRound, voteRound)`, but when `ExcludeExpiredCirculation` is disabled, this set may include accounts with expired keys — making "eligible" misleading. Additionally, §3.2 said the daemon is "permitted to exclude" ineligible senders from `total_weight`, which could be misread as the daemon having discretion beyond what `OnlineCirculation` defines.

**Fix:**

- Renamed "eligible online population" to **"circulation population"** (defined as "the population counted by `OnlineCirculation(balance_round, vote_round)`") throughout the document when used in the denominator/daemon-population context.
- Added explicit note in §1.3 that when `ExcludeExpiredCirculation` is disabled, the circulation population may include accounts with expired keys, and the daemon must match this even when counterintuitive.
- Replaced the §3.2 "permitted to exclude" language with an explicit statement that `total_weight` must exactly mirror `OnlineCirculation` and the key-validity gating is purely an algod-side optimization.

### 16.3 Fix Startup Validation Round Selection (§4.11)

**Problem:** The `validateParticipationKeyWeights()` pseudocode used `latestRound` as the base for computing `balanceRound` and checking key activity, with `ConsensusParams(latestRound)`. This does not match how `agreement/selector.go::membership()` computes these values.

**Fix:** Updated to use agreement's actual recipe:

- `voteRound = node.ledger.Latest() + 1` (the next round to be agreed upon)
- `cparams = node.ledger.ConsensusParams(agreement.ParamsRound(voteRound))`
- `balanceRound = agreement.BalanceRound(voteRound, cparams)`
- Key eligibility checks use `voteRound`, not `latestRound`
- Added snapshot-level key-validity gating (`VoteFirstValid`/`VoteLastValid` from `LookupAgreement`) matching `membership()`'s logic

**Source:** `agreement/selector.go` line 69 (`ConsensusParams(ParamsRound(r))`), `agreement/params.go` line 25 (`ParamsRound(rnd) = rnd.SubSaturate(2)`).

### 16.4 Absenteeism: Unused Variables and Zero-Weight Enforcement (§4.9)

**Problem:** After switching from `isAbsent(onlineStake, oad.VotingStake(), ...)` to `isAbsentByWeight(totalWeight, accountWeight, ...)`, the `onlineStake` and `totalOnlineStake` variables become unused, causing Go compilation errors. Additionally, `isAbsentByWeight` silently returns `false` for `acctWeight == 0`, which conflicts with the spec's non-zero weight requirement without an explicit upstream check.

**Fix:**

- **Unused variables:** Both generation and validation paths now retain `onlineStake`/`totalOnlineStake` for a cross-check: panic/error if online stake is non-zero but total weight is zero (catches daemon/ledger population mismatches). Added explanatory notes about the compilation concern.
- **Zero-weight enforcement:** Both generation and validation paths now enforce `accountWeight > 0` before calling `isAbsentByWeight()`, with panic (generation) or error return (validation) on violation. Added clarifying comment to `isAbsentByWeight` that the `acctWeight == 0` guard is a defensive fallback that should never be reached.

### 16.5 Correct `TotalMoney` Justification (§4.1, §8)

**Problem:** §4.1 stated `TotalMoney` is "needed for the stake-as-eligibility-gate check." The stake gate is `!userMoney.IsZero()` where `userMoney = m.Record.VotingStake()` — this is per-account stake and does not reference `TotalMoney`. The new credential verification code in §4.6 replaces all `TotalMoney`-based invariant checks with weight-based ones.

**Fix:** Updated §4.1 and §8 (Call Graph) to state that `TotalMoney` is retained for minimal diff but is no longer referenced in credential verification. Noted that removing it entirely is a possible future cleanup.